{"version":3,"file":"instrument.js","sources":["../../../src/browser/instrument.ts"],"sourcesContent":["import { getFunctionName, logger } from '@sentry/utils';\n\nimport { onCLS } from './web-vitals/getCLS';\nimport { onFID } from './web-vitals/getFID';\nimport { onLCP } from './web-vitals/getLCP';\nimport { observe } from './web-vitals/lib/observe';\n\ntype InstrumentHandlerTypePerformanceObserver = 'longtask' | 'event' | 'navigation' | 'paint' | 'resource';\n\ntype InstrumentHandlerTypeMetric = 'cls' | 'lcp' | 'fid';\n\n// We provide this here manually instead of relying on a global, as this is not available in non-browser environements\n// And we do not want to expose such types\ninterface PerformanceEntry {\n  readonly duration: number;\n  readonly entryType: string;\n  readonly name: string;\n  readonly startTime: number;\n  toJSON(): Record<string, unknown>;\n}\n\ninterface Metric {\n  /**\n   * The name of the metric (in acronym form).\n   */\n  name: 'CLS' | 'FCP' | 'FID' | 'INP' | 'LCP' | 'TTFB';\n\n  /**\n   * The current value of the metric.\n   */\n  value: number;\n\n  /**\n   * The rating as to whether the metric value is within the \"good\",\n   * \"needs improvement\", or \"poor\" thresholds of the metric.\n   */\n  rating: 'good' | 'needs-improvement' | 'poor';\n\n  /**\n   * The delta between the current value and the last-reported value.\n   * On the first report, `delta` and `value` will always be the same.\n   */\n  delta: number;\n\n  /**\n   * A unique ID representing this particular metric instance. This ID can\n   * be used by an analytics tool to dedupe multiple values sent for the same\n   * metric instance, or to group multiple deltas together and calculate a\n   * total. It can also be used to differentiate multiple different metric\n   * instances sent from the same page, which can happen if the page is\n   * restored from the back/forward cache (in that case new metrics object\n   * get created).\n   */\n  id: string;\n\n  /**\n   * Any performance entries relevant to the metric value calculation.\n   * The array may also be empty if the metric value was not based on any\n   * entries (e.g. a CLS value of 0 given no layout shifts).\n   */\n  entries: PerformanceEntry[];\n\n  /**\n   * The type of navigation\n   *\n   * Navigation Timing API (or `undefined` if the browser doesn't\n   * support that API). For pages that are restored from the bfcache, this\n   * value will be 'back-forward-cache'.\n   */\n  navigationType: 'navigate' | 'reload' | 'back-forward' | 'back-forward-cache' | 'prerender';\n}\n\ntype InstrumentHandlerType = InstrumentHandlerTypeMetric | InstrumentHandlerTypePerformanceObserver;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype InstrumentHandlerCallback = (data: any) => void;\n\ntype CleanupHandlerCallback = () => void;\n\nconst handlers: { [key in InstrumentHandlerType]?: InstrumentHandlerCallback[] } = {};\nconst instrumented: { [key in InstrumentHandlerType]?: boolean } = {};\n\nlet _previousCls: Metric | undefined;\nlet _previousFid: Metric | undefined;\nlet _previousLcp: Metric | undefined;\n\n/**\n * Add a callback that will be triggered when a CLS metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nexport function addClsInstrumentationHandler(callback: (data: { metric: Metric }) => void): CleanupHandlerCallback {\n  return addMetricObserver('cls', callback, instrumentCls, _previousCls);\n}\n\n/**\n * Add a callback that will be triggered when a LCP metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nexport function addLcpInstrumentationHandler(callback: (data: { metric: Metric }) => void): CleanupHandlerCallback {\n  return addMetricObserver('lcp', callback, instrumentLcp, _previousLcp);\n}\n\n/**\n * Add a callback that will be triggered when a FID metric is available.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nexport function addFidInstrumentationHandler(callback: (data: { metric: Metric }) => void): CleanupHandlerCallback {\n  return addMetricObserver('fid', callback, instrumentFid, _previousFid);\n}\n\nexport function addPerformanceInstrumentationHandler(\n  type: 'event',\n  callback: (data: { entries: (PerformanceEntry & { target?: unknown | null })[] }) => void,\n): CleanupHandlerCallback;\nexport function addPerformanceInstrumentationHandler(\n  type: InstrumentHandlerTypePerformanceObserver,\n  callback: (data: { entries: PerformanceEntry[] }) => void,\n): CleanupHandlerCallback;\n\n/**\n * Add a callback that will be triggered when a performance observer is triggered,\n * and receives the entries of the observer.\n * Returns a cleanup callback which can be called to remove the instrumentation handler.\n */\nexport function addPerformanceInstrumentationHandler(\n  type: InstrumentHandlerTypePerformanceObserver,\n  callback: (data: { entries: PerformanceEntry[] }) => void,\n): CleanupHandlerCallback {\n  addHandler(type, callback);\n\n  if (!instrumented[type]) {\n    instrumentPerformanceObserver(type);\n    instrumented[type] = true;\n  }\n\n  return getCleanupCallback(type, callback);\n}\n\n/** Trigger all handlers of a given type. */\nfunction triggerHandlers(type: InstrumentHandlerType, data: unknown): void {\n  const typeHandlers = handlers[type];\n\n  if (!typeHandlers || !typeHandlers.length) {\n    return;\n  }\n\n  for (const handler of typeHandlers) {\n    try {\n      handler(data);\n    } catch (e) {\n      __DEBUG_BUILD__ &&\n        logger.error(\n          `Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`,\n          e,\n        );\n    }\n  }\n}\n\nfunction instrumentCls(): void {\n  onCLS(metric => {\n    triggerHandlers('cls', {\n      metric,\n    });\n    _previousCls = metric;\n  });\n}\n\nfunction instrumentFid(): void {\n  onFID(metric => {\n    triggerHandlers('fid', {\n      metric,\n    });\n    _previousFid = metric;\n  });\n}\n\nfunction instrumentLcp(): void {\n  onLCP(metric => {\n    triggerHandlers('lcp', {\n      metric,\n    });\n    _previousLcp = metric;\n  });\n}\n\nfunction addMetricObserver(\n  type: InstrumentHandlerTypeMetric,\n  callback: InstrumentHandlerCallback,\n  instrumentFn: () => void,\n  previousValue: Metric | undefined,\n): CleanupHandlerCallback {\n  addHandler(type, callback);\n\n  if (!instrumented[type]) {\n    instrumentFn();\n    instrumented[type] = true;\n  }\n\n  if (previousValue) {\n    callback({ metric: previousValue });\n  }\n\n  return getCleanupCallback(type, callback);\n}\n\nfunction instrumentPerformanceObserver(type: InstrumentHandlerTypePerformanceObserver): void {\n  const options: PerformanceObserverInit = {};\n\n  // Special per-type options we want to use\n  if (type === 'event') {\n    options.durationThreshold = 0;\n  }\n\n  observe(\n    type,\n    entries => {\n      triggerHandlers(type, { entries });\n    },\n    options,\n  );\n}\n\nfunction addHandler(type: InstrumentHandlerType, handler: InstrumentHandlerCallback): void {\n  handlers[type] = handlers[type] || [];\n  (handlers[type] as InstrumentHandlerCallback[]).push(handler);\n}\n\n// Get a callback which can be called to remove the instrumentation handler\nfunction getCleanupCallback(type: InstrumentHandlerType, callback: InstrumentHandlerCallback): CleanupHandlerCallback {\n  return () => {\n    const typeHandlers = handlers[type];\n\n    if (!typeHandlers) {\n      return;\n    }\n\n    const index = typeHandlers.indexOf(callback);\n    if (index !== -1) {\n      typeHandlers.splice(index, 1);\n    }\n  };\n}\n"],"names":[],"mappings":"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"}