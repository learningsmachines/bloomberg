"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Tailwind: () => Tailwind
});
module.exports = __toCommonJS(src_exports);

// src/tailwind.tsx
var React = __toESM(require("react"));
var import_server = require("react-dom/server");
var import_tw_to_css = require("tw-to-css");

// src/utils/css-to-jsx-style.ts
var camelCase = (string) => string.replace(/-(\w|$)/g, (_, p1) => p1.toUpperCase());
var convertPropertyName = (prop) => {
  let modifiedProp = prop;
  modifiedProp = modifiedProp.toLowerCase();
  if (modifiedProp === "float") {
    return "cssFloat";
  }
  if (modifiedProp.startsWith("--")) {
    return modifiedProp;
  }
  if (modifiedProp.startsWith("-ms-")) {
    modifiedProp = modifiedProp.substr(1);
  }
  return camelCase(modifiedProp);
};
var splitDeclarations = (cssText) => {
  const declarations = [];
  let capturing;
  let i = cssText.length;
  let last = i;
  while (i-- > -1) {
    if ((cssText[i] === '"' || cssText[i] === "'") && cssText[i - 1] !== "\\") {
      if (!capturing) {
        capturing = cssText[i];
      } else if (cssText[i] === capturing) {
        capturing = false;
      }
    }
    if (!capturing && cssText[i] === ")") {
      capturing = cssText[i];
    }
    if (cssText[i] === "(" && capturing === ")") {
      capturing = false;
    }
    if (i < 0 || !capturing && cssText[i] === ";") {
      declarations.unshift(cssText.slice(i + 1, last));
      last = i;
    }
  }
  return declarations;
};
var splitDeclaration = (declaration) => {
  const i = declaration.indexOf(":");
  return [declaration.substr(0, i).trim(), declaration.substr(i + 1).trim()];
};
var cssToJsxStyle = (cssText) => splitDeclarations(cssText).map(splitDeclaration).reduce((styles, [name, value]) => {
  if (name && value) {
    styles[convertPropertyName(name)] = value;
  }
  return styles;
}, {});

// src/tailwind.tsx
var import_jsx_runtime = require("react/jsx-runtime");
function processElement(element, headStyles, twi) {
  let modifiedElement = element;
  if (modifiedElement.props.className) {
    const convertedStyles = [];
    const responsiveStyles = [];
    const classNames = modifiedElement.props.className.split(" ");
    const customClassNames = classNames.filter((className) => {
      const tailwindClassName = twi(className, { ignoreMediaQueries: true });
      if (tailwindClassName) {
        convertedStyles.push(tailwindClassName);
        return false;
      } else if (twi(className, { ignoreMediaQueries: false })) {
        responsiveStyles.push(className);
        return false;
      }
      return true;
    });
    const convertedResponsiveStyles = twi(responsiveStyles, {
      ignoreMediaQueries: false,
      merge: false
    });
    headStyles.push(
      convertedResponsiveStyles.replace(/^\n+/, "").replace(/\n+$/, "")
    );
    modifiedElement = React.cloneElement(modifiedElement, __spreadProps(__spreadValues({}, modifiedElement.props), {
      className: customClassNames.length ? customClassNames.join(" ") : void 0,
      style: __spreadValues(__spreadValues({}, modifiedElement.props.style), cssToJsxStyle(convertedStyles.join(" ")))
    }));
  }
  if (modifiedElement.props.children) {
    const children = React.Children.toArray(modifiedElement.props.children);
    const processedChildren = children.map((child) => {
      if (React.isValidElement(child)) {
        return processElement(child, headStyles, twi);
      }
      return child;
    });
    modifiedElement = React.cloneElement(
      modifiedElement,
      modifiedElement.props,
      ...processedChildren
    );
  }
  return modifiedElement;
}
function processHead(child, responsiveStyles) {
  let modifiedChild = child;
  if (modifiedChild.type === "head" || modifiedChild.type.displayName === "Head") {
    const styleElement = /* @__PURE__ */ (0, import_jsx_runtime.jsx)("style", { children: responsiveStyles });
    const headChildren = React.Children.toArray(modifiedChild.props.children);
    headChildren.push(styleElement);
    modifiedChild = React.cloneElement(
      modifiedChild,
      modifiedChild.props,
      ...headChildren
    );
  }
  if (modifiedChild.props.children) {
    const children = React.Children.toArray(modifiedChild.props.children);
    const processedChildren = children.map((processedChild) => {
      if (React.isValidElement(processedChild)) {
        return processHead(processedChild, responsiveStyles);
      }
      return processedChild;
    });
    modifiedChild = React.cloneElement(
      modifiedChild,
      modifiedChild.props,
      ...processedChildren
    );
  }
  return modifiedChild;
}
var Tailwind = ({ children, config }) => {
  const headStyles = [];
  const { twi } = (0, import_tw_to_css.tailwindToCSS)({
    config
  });
  const childrenWithInlineStyles = React.Children.map(children, (child) => {
    if (React.isValidElement(child)) {
      return processElement(child, headStyles, twi);
    }
    return child;
  });
  if (!childrenWithInlineStyles)
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
  const fullHTML = (0, import_server.renderToStaticMarkup)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: childrenWithInlineStyles }));
  const hasResponsiveStyles = new RegExp("@media[^{]+\\{(?<content>[\\s\\S]+?)\\}\\s*\\}", "gm").test(
    headStyles.join(" ")
  );
  const hasHTMLAndHead = /<html[^>]*>(?=[\s\S]*<head[^>]*>)/gm.test(fullHTML);
  if (hasResponsiveStyles && !hasHTMLAndHead) {
    throw new Error(
      "Tailwind: To use responsive styles you must have a <html> and <head> element in your template."
    );
  }
  const childrenWithInlineAndResponsiveStyles = React.Children.map(
    childrenWithInlineStyles,
    (child) => {
      if (React.isValidElement(child)) {
        return processHead(child, headStyles);
      }
      return child;
    }
  );
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: childrenWithInlineAndResponsiveStyles });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Tailwind
});
