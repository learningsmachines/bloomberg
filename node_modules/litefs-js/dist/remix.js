"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.appendTxNumberCookie = exports.handleTransactionalConsistency = exports.getReplayResponse = exports.ensureInstance = exports.ensurePrimary = exports.getTxSetCookieHeader = void 0;
// this is utilities for Remix which allows for throwing response objects
const _1 = require(".");
var _2 = require(".");
Object.defineProperty(exports, "getTxSetCookieHeader", { enumerable: true, get: function () { return _2.getTxSetCookieHeader; } });
/**
 * If the current instance is the primary instance, then returns false.
 * Otherwise, this will throw a response object with a status code of 409 and
 * the fly-replay header set to the primary instance.
 * @returns {Promise<true>} if the current instance is the primary instance
 * @throws {Response} if the current instance is not the primary instance
 * @example
 * import { ensurePrimary } from "litefs-js/remix";
 * // in server-side code ...
 * await ensurePrimary();
 * ...
 */
async function ensurePrimary() {
    const { currentIsPrimary, primaryInstance } = await (0, _1.getInstanceInfo)();
    if (currentIsPrimary)
        return true;
    throw getReplayResponse(primaryInstance);
}
exports.ensurePrimary = ensurePrimary;
/**
 * This will throw a fly replay response if the current instance is not the
 * given instance.
 *
 * @param instance the instance you want to ensure is currently running
 * @returns {Promise<true>} if the current instance is the given instance
 * @throws {Response} if the current instance is not the given instance
 */
async function ensureInstance(instance) {
    const { currentInstance } = await (0, _1.getInstanceInfo)();
    if (instance === currentInstance)
        return true;
    throw getReplayResponse(instance);
}
exports.ensureInstance = ensureInstance;
/**
 * Creates a Response object that allows you to replay the request to a different
 * instance by its hostname.
 *
 * NOTE: this uses a redirect request because otherwise, you have to manually
 * forward the headers for document requests in each route that throws this
 * replay response which is easy to forget and a bit of a pain. With a redirect,
 * Remix will simply forward the response as you make it to the browser. And in
 * our case, the response never makes it to the browser because Fly will
 * intercept it due to the fly-replay header.
 *
 * @param instance the instance you want to replay to
 * @returns {Response} the response object you should send for Fly to intercept
 * and replay the request to the given instance.
 * @example
 * import { getReplayResponse } from "litefs-js/remix";
 * // in server-side code ...
 * throw getReplayResponse('some-instance-hostname');
 * ...
 */
function getReplayResponse(instance) {
    return new Response(null, {
        status: 302,
        headers: {
            Location: '/',
            'fly-replay': `instance=${instance}`,
        },
    });
}
exports.getReplayResponse = getReplayResponse;
/**
 * Ensures that the transactional consistency cookie is set on the response object.
 * If the current instance is the primary instance, then the cookie will be deleted.
 * If the current instance is not the primary instance, then the cookie will be
 * deleted if the transaction number in the cookie is up to date. If the transaction
 * number in the cookie is not up to date, then it will wait for a bit before continuing.
 * If it's still not up-to-date after waiting, then the response will be replayed from
 * the primary instance.
 * @param {Request} request the fetch request object
 * @example
 * import { handleTransactionalConsistency } from "litefs-js/remix";
 * ...
 * const newCookie = await handleTransactionalConsistency(req);
 * if (newCookie) headers.append('Set-Cookie', newCookie);
 * ...
 * @returns {Promise<ConsistencyResult>} - the new cookies value if the tx
 * number needs to be removed.
 * @throws {Response} if the transaction number is not up to date and the
 * response needs to be replayed. Remix will handle this for you, if you catch
 * calls to this function, make sure to re-throw the error if it is an
 * instanceof Response.
 */
async function handleTransactionalConsistency(request) {
    const result = await (0, _1.checkCookieForTransactionalConsistency)(request.headers.get('Cookie'));
    if (result.type === 'replay') {
        throw getReplayResponse(result.instance);
    }
    if (result.type === 'ok')
        return { type: 'ok' };
    if (result.type === 'delete-cookie') {
        return { type: 'delete-cookie', setCookieHeader: result.setCookieHeader };
    }
    throw new Error(`Unknown status type ${result}`);
}
exports.handleTransactionalConsistency = handleTransactionalConsistency;
/**
 * Appends the transaction number cookie to the response headers if the request
 * is a mutation request if running on the primary instance. Normally this
 * should be used in the entry.server.ts file in both the default export as well as the handleDataRequest export.
 *
 * @param {Request} request the fetch request object
 * @param {Headers} headers the response headers object
 * @example
 *  import { appendTxNumberCookie } from "litefs-js/remix";
 *  ...
 *  export default function handleRequest(request: Request, responseHeaders: Headers) {
 *  	appendTxNumberCookie(request, responseHeaders);
 *  	...
 *  }
 *  ...
 *  export async function handleDataRequest(
 *  	response: Response,
 *  	{ request }: Parameters<HandleDataRequestFunction>[1],
 *  ) {
 *  	// Most of the time, all mutations are finished by now, but just make sure
 *  	// you're finished with all mutations before this line:
 *  	await appendTxNumberCookie(request, response.headers)
 *  	return response
 *  }
 *  ...
 * @returns {Promise<void>}
 */
async function appendTxNumberCookie(request, headers) {
    const mutationMethods = ['POST', 'PUT', 'PATCH', 'DELETE'];
    if (mutationMethods.includes(request.method)) {
        const { currentIsPrimary } = await (0, _1.getInstanceInfo)();
        if (currentIsPrimary) {
            headers.append('Set-Cookie', (0, _1.getTxSetCookieHeader)(await (0, _1.getTxNumber)()));
        }
    }
}
exports.appendTxNumberCookie = appendTxNumberCookie;
