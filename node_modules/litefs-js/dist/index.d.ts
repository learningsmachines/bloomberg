import type { CookieSerializeOptions } from 'cookie';
type InstanceInfo = {
    /** the hostname of the primary instance (found in the `LITEFS_DIR/.primary` file if present, falls back to `os.hostname()`) */
    primaryInstance: string;
    /** the hostname of the current instance (`os.hostname()`) */
    currentInstance: string;
    /** whether the current instance is the primary instance (`primaryInstance === currentInstance`) */
    currentIsPrimary: boolean;
};
/**
 * the directory where the .primary file is stored. Defaults to
 * process.env.LITEFS_DIR. This should be what you set your fuse.dir config to
 * in the litefs.yml config.
 */
export type LiteFSDir = string | undefined;
/**
 * The filename of your sqlite database. Defaults to
 * process.env.DATABASE_FILENAME. This is used to determine the location of
 * the "-pos" file which LiteFS uses to track the transaction number.
 */
export type DatabaseFilename = string | undefined;
/**
 * If the current instance is the primary instance, then there will be
 * no .primary file in the and the os.hostname() will be considered the primary.
 * If there is a .primary file, then the contents of that file will be the
 * hostname of the primary instance.
 *
 * NOTE: If you're using a consul lease strategy, do not cache the result of
 * this function. Instead, call it each time you need to know the instance info.
 * With the consul lease strategy, the .primary file may change at any time.
 * With a static lease strategy, the .primary file should not change and this
 * function can be cached if desired.
 *
 * @param {LiteFSDir} [litefsDir=process.env.LITEFS_DIR] - the directory where
 * the .primary file is stored. Defaults to process.env.LITEFS_DIR. This should
 * be what you set your fuse.dir config to in the litefs.yml config.
 *
 * @returns {Promise<InstanceInfo>} the primary instance hostname, the current
 * instance hostname, and whether the current instance is the primary instance
 */
export declare function getInstanceInfo(litefsDir?: LiteFSDir): Promise<InstanceInfo>;
/**
 * Just like getInstanceInfo except this runs synchronously.
 *
 * @param {LiteFSDir} [litefsDir=process.env.LITEFS_DIR] - the directory where
 * the .primary file is stored. Defaults to process.env.LITEFS_DIR. This should
 * be what you set your fuse.dir config to in the litefs.yml config.
 *
 * @returns {InstanceInfo} the primary instance hostname, the current
 * instance hostname, and whether the current instance is the primary instance
 */
export declare function getInstanceInfoSync(litefsDir?: LiteFSDir): InstanceInfo;
/**
 * The name of the cookie that should be set in the client to identify the
 * transaction number
 */
export declare const TXID_NUM_COOKIE_NAME = "txnum";
type WaitForUpToDateTxNumberOptions = {
    /**
     * the directory where the .primary file is stored. Defaults to
     * process.env.LITEFS_DIR. This should be what you set your fuse.dir config to
     * in the litefs.yml config.
     */
    litefsDir?: LiteFSDir;
    /**
     * The filename of your sqlite database. Defaults to
     * process.env.DATABASE_FILENAME. This is used to determine the location of
     * the "-pos" file which LiteFS uses to track the transaction number.
     */
    databaseFilename?: DatabaseFilename;
    /**
     * The maximum amount of time (in milliseconds) to wait for the transaction
     * number to catch up to the client's transaction number. Defaults to 500.
     */
    timeoutMs?: number;
    /**
     * The amount of time (in milliseconds) to wait between checking the
     * transaction number. Defaults to 30.
     */
    intervalMs?: number;
};
/**
 * @param {number} clientTxNumber - the transaction number that the client is
 * expecting
 * @param {WaitForUpToDateTxNumberOptions} [options]
 *
 * @returns {Promise<boolean>} - resolves to true if it's safe to continue or
 * false if the request should be replayed on the primary
 */
export declare function waitForUpToDateTxNumber(clientTxNumber: number, { litefsDir, databaseFilename, timeoutMs, intervalMs, }?: WaitForUpToDateTxNumberOptions): Promise<boolean>;
/**
 * @param {LiteFSDir} [litefsDir=process.env.LITEFS_DIR] - the directory where
 * the .primary file is stored. Defaults to process.env.LITEFS_DIR. This should
 * be what you set your fuse.dir config to in the litefs.yml config.
 *
 * @param {DatabaseFilename} [databaseFilename=process.env.DATABASE_FILENAME]
 * - The filename of your sqlite database. Defaults to
 * process.env.DATABASE_FILENAME. This is used to determine the location of
 * the "-pos" file which LiteFS uses to track the transaction number.
 *
 * @returns {Promise<number>} the current transaction number
 */
export declare function getTxNumber(litefsDir?: LiteFSDir, databaseFilename?: DatabaseFilename): Promise<number>;
/**
 * Creates a seralized cookie header for the txnum cookie which you should use
 * with a 'Set-Cookie' header to set the cookie in the client.
 *
 * @param {string} value - the value of the cookie (get this from `await getTxNumber()`).
 * @param {CookieSerializeOptions} [options] - options to pass to cookie.serialize
 * to override the defaults of path: "/", httpOnly: true, sameSite: "lax",
 * secure: true.
 *
 * @returns {number} the current transaction number
 */
export declare function getTxSetCookieHeader(value: number, options?: CookieSerializeOptions): string;
type ConsistencyResult = {
    type: 'ok';
} | {
    type: 'delete-cookie';
    setCookieHeader: string;
} | {
    type: 'replay';
    flyReplayHeader: string;
    instance: string;
};
/**
 * Ensures that the transactional consistency cookie is set on the response object.
 * If the current instance is the primary instance, then the cookie will be deleted.
 * If the current instance is not the primary instance, then the cookie will be
 * deleted if the transaction number in the cookie is up to date. If the transaction
 * number in the cookie is not up to date, then the response will be replayed from
 * the primary instance.
 *
 * @param {string | null} cookieHeader - the value of the 'Cookie' header from the
 * request.
 *
 *  @example
 *  import { checkCookieForTransactionalConsistency } from "litefs-js/http";
 *  ...
 *  const status = await checkCookieForTransactionalConsistency(req, res);
 *  if (status === 'replay') {
 *  	res.setHeader('fly-replay', `instance=${primaryInstance}`)
 *  	res.writeHead(409)
 *  	res.end()
 *  	return true
 *  } else if (status === 'delete-cookie') {
 *  	appendHeader(res, 'Set-Cookie', getTxSetCookieHeader(0, { maxAge: 0 }))
 *  ...
 *  } else if (status === 'ok') {
 *  	// continue with request
 *  }
 *  ...
 *
 * @returns {Promise<ConsistencyResult>} - resolves to 'ok' if the request should continue,
 * 'delete-cookie' if the cookie should be deleted, or 'replay' if the request
 * should be replayed on the primary instance.
 */
export declare function checkCookieForTransactionalConsistency(cookieHeader: string | null | undefined): Promise<ConsistencyResult>;
/**
 * Returns the internal domain for the given instance.
 * @example
 * import { getInternalInstanceDomain } from "litefs-js/http";
 * ...
 * const internalDomain = getInternalInstanceDomain("primary")
 * // internalDomain === "http://5ef6ddf5.vm.myapp.internal:8081"
 * ...
 */
export declare function getInternalInstanceDomain(instance: string, port?: string | void): string;
/**
 * Gives an object of instance ids mapped to the region where they're hosted.
 * @example
 * import { getAllInstances } from "litefs-js/http";
 * ...
 * const instances = await getAllInstances()
 * // instances === { "5ef6ddf5": "maa", "5ef6ddf6": "sjc", "5ef6ddf7": "ams" }
 * ...
 */
export declare function getAllInstances(): Promise<Record<string, string> | {
    [x: string]: string[];
}>;
export {};
