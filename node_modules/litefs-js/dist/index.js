"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllInstances = exports.getInternalInstanceDomain = exports.checkCookieForTransactionalConsistency = exports.getTxSetCookieHeader = exports.getTxNumber = exports.waitForUpToDateTxNumber = exports.TXID_NUM_COOKIE_NAME = exports.getInstanceInfoSync = exports.getInstanceInfo = void 0;
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const dns_1 = __importDefault(require("dns"));
const cookie_1 = __importDefault(require("cookie"));
/**
 * If the current instance is the primary instance, then there will be
 * no .primary file in the and the os.hostname() will be considered the primary.
 * If there is a .primary file, then the contents of that file will be the
 * hostname of the primary instance.
 *
 * NOTE: If you're using a consul lease strategy, do not cache the result of
 * this function. Instead, call it each time you need to know the instance info.
 * With the consul lease strategy, the .primary file may change at any time.
 * With a static lease strategy, the .primary file should not change and this
 * function can be cached if desired.
 *
 * @param {LiteFSDir} [litefsDir=process.env.LITEFS_DIR] - the directory where
 * the .primary file is stored. Defaults to process.env.LITEFS_DIR. This should
 * be what you set your fuse.dir config to in the litefs.yml config.
 *
 * @returns {Promise<InstanceInfo>} the primary instance hostname, the current
 * instance hostname, and whether the current instance is the primary instance
 */
async function getInstanceInfo(litefsDir = process.env.LITEFS_DIR) {
    if (!litefsDir) {
        throw new Error('litefs-js: LITEFS_DIR is not defined. You must either set the LITEFS_DIR environment variable or pass the litefsDir argument to getInstanceInfo');
    }
    const currentInstance = os_1.default.hostname();
    let primaryInstance;
    try {
        primaryInstance = await fs_1.default.promises.readFile(path_1.default.join(litefsDir, '.primary'), 'utf8');
        primaryInstance = primaryInstance.trim();
    }
    catch {
        primaryInstance = currentInstance;
    }
    return {
        primaryInstance,
        currentInstance,
        currentIsPrimary: currentInstance === primaryInstance,
    };
}
exports.getInstanceInfo = getInstanceInfo;
/**
 * Just like getInstanceInfo except this runs synchronously.
 *
 * @param {LiteFSDir} [litefsDir=process.env.LITEFS_DIR] - the directory where
 * the .primary file is stored. Defaults to process.env.LITEFS_DIR. This should
 * be what you set your fuse.dir config to in the litefs.yml config.
 *
 * @returns {InstanceInfo} the primary instance hostname, the current
 * instance hostname, and whether the current instance is the primary instance
 */
function getInstanceInfoSync(litefsDir = process.env.LITEFS_DIR) {
    if (!litefsDir) {
        throw new Error('litefs-js: LITEFS_DIR is not defined. You must either set the LITEFS_DIR environment variable or pass the litefsDir argument to getInstanceInfo');
    }
    const currentInstance = os_1.default.hostname();
    let primaryInstance;
    try {
        primaryInstance = fs_1.default.readFileSync(path_1.default.join(litefsDir, '.primary'), 'utf8');
        primaryInstance = primaryInstance.trim();
    }
    catch {
        primaryInstance = currentInstance;
    }
    return {
        primaryInstance,
        currentInstance,
        currentIsPrimary: currentInstance === primaryInstance,
    };
}
exports.getInstanceInfoSync = getInstanceInfoSync;
/**
 * The name of the cookie that should be set in the client to identify the
 * transaction number
 */
exports.TXID_NUM_COOKIE_NAME = 'txnum';
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
/**
 * @param {number} clientTxNumber - the transaction number that the client is
 * expecting
 * @param {WaitForUpToDateTxNumberOptions} [options]
 *
 * @returns {Promise<boolean>} - resolves to true if it's safe to continue or
 * false if the request should be replayed on the primary
 */
async function waitForUpToDateTxNumber(clientTxNumber, { litefsDir, databaseFilename, timeoutMs = 500, intervalMs = 30, } = {}) {
    let currentTxNumber = await getTxNumber(litefsDir, databaseFilename);
    if (currentTxNumber >= clientTxNumber)
        return true;
    const stopTime = Date.now() + timeoutMs;
    do {
        await sleep(intervalMs);
        currentTxNumber = await getTxNumber();
    } while (currentTxNumber >= clientTxNumber && Date.now() < stopTime);
    if (currentTxNumber >= clientTxNumber) {
        return true;
    }
    else {
        console.error(`Timed out waiting for tx number ðŸš¨`);
        return false;
    }
}
exports.waitForUpToDateTxNumber = waitForUpToDateTxNumber;
/**
 * @param {LiteFSDir} [litefsDir=process.env.LITEFS_DIR] - the directory where
 * the .primary file is stored. Defaults to process.env.LITEFS_DIR. This should
 * be what you set your fuse.dir config to in the litefs.yml config.
 *
 * @param {DatabaseFilename} [databaseFilename=process.env.DATABASE_FILENAME]
 * - The filename of your sqlite database. Defaults to
 * process.env.DATABASE_FILENAME. This is used to determine the location of
 * the "-pos" file which LiteFS uses to track the transaction number.
 *
 * @returns {Promise<number>} the current transaction number
 */
async function getTxNumber(litefsDir = process.env.LITEFS_DIR, databaseFilename = process.env.DATABASE_FILENAME) {
    if (!litefsDir) {
        throw new Error('litefs-js: LITEFS_DIR is not defined. You must either set the LITEFS_DIR environment variable or pass the litefsDir argument to getTxNumber');
    }
    if (!databaseFilename) {
        throw new Error('litefs-js: DATABASE_FILENAME is not defined. You must either set the DATABASE_FILENAME environment variable or pass the databaseFilename argument to getTxNumber');
    }
    try {
        const dbPos = await fs_1.default.promises.readFile(path_1.default.join(litefsDir, `${databaseFilename}-pos`), 'utf-8');
        return parseInt(dbPos.trim().split('/')[0], 16);
    }
    catch (error) {
        console.error(`Error reading ${databaseFilename}-pos (will default to "0"):`, error);
        return 0;
    }
}
exports.getTxNumber = getTxNumber;
/**
 * Creates a seralized cookie header for the txnum cookie which you should use
 * with a 'Set-Cookie' header to set the cookie in the client.
 *
 * @param {string} value - the value of the cookie (get this from `await getTxNumber()`).
 * @param {CookieSerializeOptions} [options] - options to pass to cookie.serialize
 * to override the defaults of path: "/", httpOnly: true, sameSite: "lax",
 * secure: true.
 *
 * @returns {number} the current transaction number
 */
function getTxSetCookieHeader(value, options) {
    return cookie_1.default.serialize(exports.TXID_NUM_COOKIE_NAME, String(value), {
        path: '/',
        httpOnly: true,
        sameSite: 'lax',
        secure: true,
        ...options,
    });
}
exports.getTxSetCookieHeader = getTxSetCookieHeader;
/**
 * Ensures that the transactional consistency cookie is set on the response object.
 * If the current instance is the primary instance, then the cookie will be deleted.
 * If the current instance is not the primary instance, then the cookie will be
 * deleted if the transaction number in the cookie is up to date. If the transaction
 * number in the cookie is not up to date, then the response will be replayed from
 * the primary instance.
 *
 * @param {string | null} cookieHeader - the value of the 'Cookie' header from the
 * request.
 *
 *  @example
 *  import { checkCookieForTransactionalConsistency } from "litefs-js/http";
 *  ...
 *  const status = await checkCookieForTransactionalConsistency(req, res);
 *  if (status === 'replay') {
 *  	res.setHeader('fly-replay', `instance=${primaryInstance}`)
 *  	res.writeHead(409)
 *  	res.end()
 *  	return true
 *  } else if (status === 'delete-cookie') {
 *  	appendHeader(res, 'Set-Cookie', getTxSetCookieHeader(0, { maxAge: 0 }))
 *  ...
 *  } else if (status === 'ok') {
 *  	// continue with request
 *  }
 *  ...
 *
 * @returns {Promise<ConsistencyResult>} - resolves to 'ok' if the request should continue,
 * 'delete-cookie' if the cookie should be deleted, or 'replay' if the request
 * should be replayed on the primary instance.
 */
async function checkCookieForTransactionalConsistency(cookieHeader) {
    const cookies = cookieHeader ? cookie_1.default.parse(cookieHeader) : {};
    const txCookieValue = cookies[exports.TXID_NUM_COOKIE_NAME];
    const txCookieNumber = Number(txCookieValue);
    const isValidTxNumber = Number.isFinite(txCookieNumber);
    const deleteCookieHeader = () => getTxSetCookieHeader(0, { expires: new Date(0) });
    if (!isValidTxNumber) {
        if (txCookieValue) {
            console.error(`Invalid tx number in cookie: ${txCookieValue}. Deleting cookie.`);
            return { type: 'delete-cookie', setCookieHeader: deleteCookieHeader() };
        }
        return { type: 'ok' };
    }
    const { primaryInstance, currentIsPrimary } = await getInstanceInfo();
    const currentTxNumber = await getTxNumber();
    if (currentIsPrimary) {
        if (txCookieNumber > currentTxNumber) {
            console.error(`User somehow had a newer tx number (${txCookieNumber}) than the primary instance (${currentTxNumber}). Deleting cookie.`);
        }
        return { type: 'delete-cookie', setCookieHeader: deleteCookieHeader() };
    }
    const txNumberIsUpToDate = await waitForUpToDateTxNumber(txCookieNumber);
    if (txNumberIsUpToDate) {
        return { type: 'delete-cookie', setCookieHeader: deleteCookieHeader() };
    }
    else {
        return {
            type: 'replay',
            flyReplayHeader: `instance=${primaryInstance}`,
            instance: primaryInstance,
        };
    }
}
exports.checkCookieForTransactionalConsistency = checkCookieForTransactionalConsistency;
/**
 * Returns the internal domain for the given instance.
 * @example
 * import { getInternalInstanceDomain } from "litefs-js/http";
 * ...
 * const internalDomain = getInternalInstanceDomain("primary")
 * // internalDomain === "http://5ef6ddf5.vm.myapp.internal:8081"
 * ...
 */
function getInternalInstanceDomain(instance, port = process.env.INTERNAL_PORT ??
    process.env.PORT ??
    panic('INTERNAL_PORT or PORT must be set or a port must be supplied')) {
    // http and specify port for internal vm requests
    return `http://${instance}.vm.${process.env.FLY_APP_NAME}.internal:${port}`;
}
exports.getInternalInstanceDomain = getInternalInstanceDomain;
/**
 * Gives an object of instance ids mapped to the region where they're hosted.
 * @example
 * import { getAllInstances } from "litefs-js/http";
 * ...
 * const instances = await getAllInstances()
 * // instances === { "5ef6ddf5": "maa", "5ef6ddf6": "sjc", "5ef6ddf7": "ams" }
 * ...
 */
async function getAllInstances() {
    if (!process.env.FLY_APP_NAME) {
        return { [os_1.default.hostname()]: 'local' };
    }
    try {
        const rawTxts = await dns_1.default.promises.resolveTxt(`vms.${process.env.FLY_APP_NAME ?? 'local'}.internal`);
        const instances = rawTxts
            .flat()
            .flatMap(r => r.split(','))
            .map(vm => vm.split(' '))
            .reduce((all, [instanceId, region]) => instanceId && region ? { ...all, [instanceId]: region } : all, {});
        return instances;
    }
    catch (error) {
        console.error('Error getting all instances', error);
        return { [os_1.default.hostname()]: [process.env.FLY_REGION ?? 'local'] };
    }
}
exports.getAllInstances = getAllInstances;
function panic(message) {
    throw message;
}
