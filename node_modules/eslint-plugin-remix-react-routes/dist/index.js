"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/remix/remixShim.js
var require_remixShim = __commonJS({
  "src/remix/remixShim.js"(exports, module2) {
    "use strict";
    var remixDevPackage = require("@remix-run/dev/package.json");
    var semver = require("semver");
    var specifierBase = semver.lt(remixDevPackage.version, "1.6.2") ? "@remix-run/dev" : "@remix-run/dev/dist";
    var { readConfig } = require(`${specifierBase}/config`);
    var { formatRoutesAsJson: formatRoutesAsJson2 } = require(`${specifierBase}/config/format`);
    module2.exports = { readConfig, formatRoutesAsJson: formatRoutesAsJson2 };
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  configs: () => configs_exports,
  rules: () => rules
});
module.exports = __toCommonJS(src_exports);

// src/remix/context.ts
var path3 = __toESM(require("path"));

// src/remix/appConfig.ts
var path2 = __toESM(require("path"));
var import_fs = __toESM(require("fs"));
var chokidar = __toESM(require("chokidar"));
var import_remixShim = __toESM(require_remixShim());

// src/readConfigSync.ts
var path = __toESM(require("path"));
var import_synckit = require("synckit");
var readConfigSync = (0, import_synckit.createSyncFn)(
  path.join(__dirname, "./readConfigWorker.js")
);

// src/remix/appConfig.ts
var remixApps = {};
var configBase = "remix.config";
var configExts = [".js", ".cjs", ".mjs"];
var _watchers = {};
function watchRemixAppConfig(projectPath, appConfig, recreate) {
  var _a;
  if (_watchers[projectPath] && !recreate)
    return;
  debug(`${recreate ? "recreating" : "creating"} watcher for ${projectPath}`);
  (_a = _watchers[projectPath]) == null ? void 0 : _a.call(_watchers);
  let ready = false;
  let active = true;
  const routesDir = path2.join(appConfig.appDirectory, "routes");
  const watcher = chokidar.watch([
    path2.join(projectPath, `${configBase}{${configExts.join(",")}}`),
    routesDir
  ]);
  watcher.on("ready", () => ready = true);
  watcher.on("add", (changedPath) => {
    if (!ready || !active)
      return;
    debug(`added ${changedPath}`);
    loadAppConfig(projectPath, true);
  });
  watcher.on("unlink", (changedPath) => {
    if (!ready || !active)
      return;
    debug(`removed ${changedPath}`);
    loadAppConfig(projectPath, true);
  });
  watcher.on("change", (changedPath) => {
    if (!ready || !active || changedPath.startsWith(routesDir))
      return;
    debug(`changed ${changedPath}`);
    try {
      loadAppConfig(projectPath, true, true);
    } catch (e) {
      console.error(e);
    }
  });
  _watchers[projectPath] = () => {
    active = false;
    watcher.close();
  };
}
function debug(...values) {
  if (process.env.DEBUG)
    values.forEach((value) => console.warn(value));
}
function loadAppConfig(projectPath, watchForChanges2, recreateWatcher = false) {
  const appConfig = readConfigSync(projectPath);
  appConfig.routes = JSON.parse((0, import_remixShim.formatRoutesAsJson)(appConfig.routes));
  if (watchForChanges2)
    watchRemixAppConfig(projectPath, appConfig, recreateWatcher);
  debug("loaded app config", JSON.stringify(appConfig, null, 2));
  return remixApps[projectPath] = appConfig;
}
function getRemixAppConfig(filename, watchForChanges2 = false) {
  for (const projectPath in remixApps) {
    if (filename.startsWith(projectPath))
      return remixApps[projectPath];
  }
  return _maybeFindRemixAppConfig(filename, watchForChanges2);
}
var visited = /* @__PURE__ */ new Map();
function _maybeFindRemixAppConfig(filename, watchForChanges2) {
  const dir = path2.dirname(filename);
  if (dir === filename)
    return;
  if (visited.has(dir))
    return;
  try {
    for (const ext of configExts) {
      const file = path2.resolve(dir, configBase + ext);
      if (import_fs.default.existsSync(file)) {
        return loadAppConfig(dir, watchForChanges2);
      }
    }
  } finally {
    visited.set(dir, true);
  }
  return _maybeFindRemixAppConfig(dir, watchForChanges2);
}

// src/remix/context.ts
var watchForChanges = isRunningInVSCodeServer();
function isRunningInVSCodeServer() {
  return process.exit.toString().includes("ExitCalled.type");
}
function validateRoute(routes, routePath) {
  if (!routePath.startsWith("/"))
    throw new Error("Path must be absolute");
  return _validateRouteParts(routePath.substring(1).split("/"), routes);
}
function _validateRouteParts(parts, routes) {
  if (parts.length === 0)
    return true;
  return routes.some((route) => {
    var _a, _b;
    if (parts.length === 1 && parts[0] === "" && route.index)
      return true;
    if (!route.path)
      return _validateRouteParts(parts, (_a = route.children) != null ? _a : []);
    const routeParts = route.path.split("/");
    if (routeParts[routeParts.length - 1] === "*")
      return true;
    return routeParts.every((rp, i) => rp === parts[i] || rp.startsWith(":")) && _validateRouteParts(parts.slice(routeParts.length), (_b = route.children) != null ? _b : []);
  });
}
function findRoutePathByFilename(filename, { appDirectory, routes }) {
  const relativeFilename = path3.relative(appDirectory, filename);
  return _findRoutePathByFilename(relativeFilename, routes);
}
function _findRoutePathByFilename(filename, routes, pathParts = []) {
  var _a;
  for (const route of routes) {
    if (filename === route.file) {
      return "/" + (route.path ? [...pathParts, route.path] : pathParts).join("/");
    } else if (route.id === "root" || filename.startsWith(route.id)) {
      return _findRoutePathByFilename(
        filename,
        (_a = route.children) != null ? _a : [],
        route.path ? [...pathParts, route.path] : pathParts
      );
    }
  }
}
function getRemixContext(context) {
  var _a, _b, _c, _d;
  if ((_b = (_a = context.settings) == null ? void 0 : _a.remixReactRoutes) == null ? void 0 : _b.mockRemixContext) {
    return {
      validateRoute: () => true,
      ...(_d = (_c = context.settings) == null ? void 0 : _c.remixReactRoutes) == null ? void 0 : _d.mockRemixContext
    };
  }
  const filename = context.getFilename();
  let appConfig;
  try {
    appConfig = getRemixAppConfig(filename, watchForChanges);
  } catch (e) {
    console.warn(
      `Error loading Remix config, remix-react-routes rules will be skipped:`,
      e
    );
  }
  const currentRoutePath = appConfig ? findRoutePathByFilename(filename, appConfig) : void 0;
  return {
    appConfig,
    currentRoutePath,
    validateRoute: (routePath) => {
      var _a2;
      return validateRoute((_a2 = appConfig == null ? void 0 : appConfig.routes) != null ? _a2 : [], routePath);
    }
  };
}

// src/ast.ts
var import_utils = require("@typescript-eslint/utils");
var EXPR_PLACEHOLDER = "--__EXPR_PLACEHOLDER__--";
var mergePattern = new RegExp(`[^/]*${EXPR_PLACEHOLDER}[^/]*`, "g");
function getPathValue(path5) {
  return path5.replace(mergePattern, ":param").replace(/(\?|#).*/, "");
}
function resolveTemplateLiteralExpressions({ expressions, quasis }, resolveType) {
  const result = [];
  let current;
  quasis.forEach((quasi, i) => {
    current = `${typeof current !== "undefined" ? current : ""}${quasi.value.cooked}`;
    if (i === expressions.length) {
      result.push(current);
      return;
    }
    const exprStringValue = getNodeStringValue(expressions[i], resolveType);
    if (exprStringValue !== null) {
      current += exprStringValue;
      return;
    }
    result.push(current);
    current = void 0;
  });
  return result.join(EXPR_PLACEHOLDER);
}
function getNodeStringValue(node, resolveType) {
  switch (node.type) {
    case "JSXExpressionContainer":
      return getNodeStringValue(node.expression, resolveType);
    case "Literal":
      return getStringLiteralValue(node);
    case "TemplateLiteral":
      return resolveTemplateLiteralExpressions(node, resolveType);
    default:
      const nodeType = resolveType(node);
      if (nodeType == null ? void 0 : nodeType.isLiteral())
        return String(nodeType.value);
  }
  return null;
}
function getStringLiteralValue(node) {
  return String(node.value);
}
function forEachStringAttribute(node, resolveType, attributeMatchers, cb) {
  if (node.openingElement.name.type !== "JSXIdentifier")
    return;
  const {
    attributes,
    name: { name: componentName }
  } = node.openingElement;
  attributeMatchers = attributeMatchers.filter(
    ({ component }) => component === componentName
  );
  for (const attribute of attributes) {
    if (attribute.type !== "JSXAttribute")
      continue;
    if (!attribute.value)
      continue;
    const matcher = attributeMatchers.find(
      (ca) => ca.attribute === attribute.name.name
    );
    if (!matcher)
      continue;
    const value = getNodeStringValue(attribute.value, resolveType);
    const loc = attribute.value.loc;
    if (typeof value === "undefined")
      continue;
    cb({ ...matcher, value, loc });
  }
}
function buildResolveType(context) {
  try {
    const parserServices = import_utils.ESLintUtils.getParserServices(context);
    const typeChecker = parserServices.program.getTypeChecker();
    return (node) => {
      const originalNode = parserServices.esTreeNodeToTSNodeMap.get(node);
      return typeChecker.getTypeAtLocation(originalNode);
    };
  } catch (e) {
    return () => {
    };
  }
}

// src/rules/common.ts
var import_utils2 = require("@typescript-eslint/utils");
var createRule = import_utils2.ESLintUtils.RuleCreator(
  (name) => `https://github.com/jenseng/eslint-plugin-remix-react-routes/rules/${name}/README.md`
);
function resolvePath(fromPath, toPath) {
  if (isAbsolute(toPath))
    return toPath;
  if (!fromPath)
    return void 0;
  const parts = `${fromPath === "/" ? "" : fromPath}/${toPath}`.split("/");
  const result = [];
  for (const part of parts) {
    if (part === "..")
      result.pop();
    else if (part !== ".")
      result.push(part);
  }
  const resolved = result.join("/");
  return resolved.match(/.\/$/) ? resolved.substring(0, resolved.length - 1) : resolved;
}
function isAbsolute(path5) {
  return path5.startsWith("/");
}
var RoutingComponentAttributeMatchers = [
  { component: "Link", attribute: "to", nativeAlternative: "<a href>" },
  { component: "NavLink", attribute: "to", nativeAlternative: "<a href>" },
  {
    component: "Form",
    attribute: "action",
    nativeAlternative: "<form action>"
  }
];
var IS_A_URI = /^(\w+:)?\/\//;
function isAUri(path5) {
  return path5.match(IS_A_URI);
}

// src/rules/no-relative-paths/index.ts
var import_path = __toESM(require("path"));
var defaultOptions = {
  enforceInRouteComponents: false,
  allowLinksToSelf: true
};
var no_relative_paths_default = createRule({
  create(context) {
    var _a;
    const resolveType = buildResolveType(context);
    const { currentRoutePath } = getRemixContext(context);
    const options = { ...defaultOptions, ...(_a = context.options[0]) != null ? _a : {} };
    if (currentRoutePath && !options.enforceInRouteComponents)
      return {};
    return {
      JSXElement(node) {
        forEachStringAttribute(
          node,
          resolveType,
          RoutingComponentAttributeMatchers,
          ({ component, attribute, value, loc }) => {
            const toPath = getPathValue(value != null ? value : "");
            if (isAbsolute(toPath))
              return;
            if (isAUri(toPath))
              return;
            if (options.allowLinksToSelf && import_path.default.relative(".", toPath) === "")
              return;
            context.report({
              messageId: currentRoutePath ? "relativePath" : "ambiguousPath",
              loc,
              data: {
                toPath,
                component,
                attribute
              }
            });
          }
        );
      }
    };
  },
  name: "no-relative-paths",
  meta: {
    docs: {
      description: "Ensure <Link> and friends have absolute paths when used outside of a route.",
      recommended: "error"
    },
    messages: {
      relativePath: 'Relative route path "{{toPath}}". Specify absolute paths when using `<{{component}} {{attribute}}>`.',
      ambiguousPath: 'Ambiguous route path "{{toPath}}". Specify absolute paths when using `<{{component}} {{attribute}}>` outside of a route.'
    },
    type: "suggestion",
    schema: [
      {
        type: "object",
        properties: {
          enforceInRouteComponents: {
            type: "boolean"
          },
          allowLinksToSelf: {
            type: "boolean"
          }
        },
        additionalProperties: false
      }
    ]
  },
  defaultOptions: [defaultOptions]
});

// src/rules/no-urls/index.ts
var no_urls_default = createRule({
  create(context) {
    const resolveType = buildResolveType(context);
    return {
      JSXElement(node) {
        forEachStringAttribute(
          node,
          resolveType,
          RoutingComponentAttributeMatchers,
          ({ nativeAlternative, value, component, attribute, loc }) => {
            const toPath = getPathValue(value != null ? value : "");
            if (!isAUri(toPath))
              return;
            return context.report({
              messageId: "urlAsPath",
              loc,
              data: { component, attribute, nativeAlternative }
            });
          }
        );
      }
    };
  },
  name: "no-urls",
  meta: {
    docs: {
      description: "Ensure <Link> and friends use paths rather than URLs.",
      recommended: "error"
    },
    messages: {
      urlAsPath: `\`<{{component}} {{attribute}}>\` does not support URLs, only paths. Consider using \`{{nativeAlternative}}\` instead.`
    },
    type: "suggestion",
    schema: []
  },
  defaultOptions: []
});

// src/rules/require-valid-paths/index.ts
var require_valid_paths_default = createRule({
  create(context) {
    const resolveType = buildResolveType(context);
    const { appConfig, currentRoutePath, validateRoute: validateRoute2 } = getRemixContext(context);
    if (!appConfig)
      return {};
    return {
      JSXElement(node) {
        forEachStringAttribute(
          node,
          resolveType,
          RoutingComponentAttributeMatchers,
          ({ value, loc }) => {
            var _a;
            if (value === null) {
              if ((_a = context.settings.remixReactRoutes) == null ? void 0 : _a.strictMode)
                context.report({
                  messageId: "indeterminatePath",
                  loc
                });
              return;
            }
            const toPath = getPathValue(value != null ? value : "");
            const toPathNormalized = resolvePath(currentRoutePath, toPath);
            if (!toPathNormalized)
              return;
            if (isAUri(toPath))
              return;
            if (validateRoute2(toPathNormalized))
              return;
            return context.report({
              messageId: "invalidPath",
              loc,
              data: { toPathNormalized }
            });
          }
        );
      }
    };
  },
  name: "require-valid-paths",
  meta: {
    docs: {
      description: "Ensure <Link> and friends point to actual routes in the app.",
      recommended: "error"
    },
    messages: {
      invalidPath: 'No route matches "{{toPathNormalized}}". Either create one, or point to a valid route.',
      indeterminatePath: "Unable to resolve route path statically. Consider providing a constant value."
    },
    type: "suggestion",
    schema: []
  },
  defaultOptions: []
});

// src/rules/use-link-for-routes/index.ts
var use_link_for_routes_default = createRule({
  create(context) {
    const resolveType = buildResolveType(context);
    return {
      JSXElement(node) {
        forEachStringAttribute(
          node,
          resolveType,
          [{ component: "a", attribute: "href" }],
          ({ value, loc }) => {
            var _a;
            if (value === null) {
              if ((_a = context.settings.remixReactRoutes) == null ? void 0 : _a.strictMode)
                context.report({
                  messageId: "indeterminateUrl",
                  loc
                });
              return;
            }
            const toPath = getPathValue(value != null ? value : "");
            if (isAUri(toPath))
              return;
            return context.report({ messageId: "anchorForRoute", loc });
          }
        );
      }
    };
  },
  name: "use-link-for-routes",
  meta: {
    docs: {
      description: "Ensure routes are linked via <Link to> rather than <a href>",
      recommended: "error"
    },
    messages: {
      anchorForRoute: "Use `<Link to>` when linking within the app. If you want for force a full page load, use `<Link to=... reloadDocument>`.",
      indeterminateUrl: "Unable to resolve URL statically. Consider providing a constant value."
    },
    type: "suggestion",
    schema: []
  },
  defaultOptions: []
});

// src/rules/index.ts
var rules = {
  "no-relative-paths": no_relative_paths_default,
  "no-urls": no_urls_default,
  "require-valid-paths": require_valid_paths_default,
  "use-link-for-routes": use_link_for_routes_default
};

// src/configs/index.ts
var configs_exports = {};
__export(configs_exports, {
  recommended: () => recommended,
  strict: () => strict
});

// src/configs/recommended.ts
var recommended = {
  plugins: ["remix-react-routes"],
  rules: {
    "remix-react-routes/use-link-for-routes": "error",
    "remix-react-routes/require-valid-paths": "error",
    "remix-react-routes/no-relative-paths": "error",
    "remix-react-routes/no-urls": "error"
  }
};

// src/configs/strict.ts
var strict = {
  plugins: ["remix-react-routes"],
  rules: {
    "remix-react-routes/use-link-for-routes": "error",
    "remix-react-routes/require-valid-paths": "error",
    "remix-react-routes/no-relative-paths": [
      "error",
      { enforceInRouteComponents: true }
    ],
    "remix-react-routes/no-urls": "error"
  },
  settings: {
    remixReactRoutes: {
      strictMode: true
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  configs,
  rules
});
