'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('./_virtual/_rollupPluginBabelHelpers.js');
var dom = require('@conform-to/dom');

/**
 * Cleanup `undefined` from the dervied props
 * To minimize conflicts when merging with user defined props
 */
function cleanup(props) {
  for (var key in props) {
    if (props[key] === undefined) {
      delete props[key];
    }
  }
  return props;
}
function getFormElementProps(config) {
  var _options$ariaAttribut, _config$error, _config$error2;
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var hasAriaAttributes = (_options$ariaAttribut = options.ariaAttributes) !== null && _options$ariaAttribut !== void 0 ? _options$ariaAttribut : true;
  return cleanup({
    id: config.id,
    name: config.name,
    form: config.form,
    'aria-invalid': hasAriaAttributes && config.errorId && (_config$error = config.error) !== null && _config$error !== void 0 && _config$error.length ? true : undefined,
    'aria-describedby': hasAriaAttributes ? [config.errorId && (_config$error2 = config.error) !== null && _config$error2 !== void 0 && _config$error2.length ? config.errorId : undefined, config.descriptionId && options.ariaAttributes !== false && options.description ? config.descriptionId : undefined].reduce((result, id) => {
      if (!result) {
        return id;
      }
      if (!id) {
        return result;
      }
      return "".concat(result, " ").concat(id);
    }) : undefined
  });
}
function getFormControlProps(config, options) {
  return cleanup(_rollupPluginBabelHelpers.objectSpread2(_rollupPluginBabelHelpers.objectSpread2({}, getFormElementProps(config, options)), {}, {
    required: config.required,
    autoFocus: config.initialError && Object.entries(config.initialError).length > 0 ? true : undefined
  }, options !== null && options !== void 0 && options.hidden ? hiddenProps : undefined));
}
var hiddenProps = {
  /**
   * Style to make the input element visually hidden
   * Based on the `sr-only` class from tailwindcss
   */
  style: {
    position: 'absolute',
    width: '1px',
    height: '1px',
    padding: 0,
    margin: '-1px',
    overflow: 'hidden',
    clip: 'rect(0,0,0,0)',
    whiteSpace: 'nowrap',
    border: 0
  },
  tabIndex: -1,
  'aria-hidden': true
};
function input(config) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var props = _rollupPluginBabelHelpers.objectSpread2(_rollupPluginBabelHelpers.objectSpread2({}, getFormControlProps(config, options)), {}, {
    type: options.type,
    minLength: config.minLength,
    maxLength: config.maxLength,
    min: config.min,
    max: config.max,
    step: config.step,
    pattern: config.pattern,
    multiple: config.multiple
  });
  if (options.type === 'checkbox' || options.type === 'radio') {
    var _options$value;
    props.value = (_options$value = options.value) !== null && _options$value !== void 0 ? _options$value : 'on';
    props.defaultChecked = config.defaultValue === props.value;
  } else if (options.type !== 'file') {
    props.defaultValue = config.defaultValue;
  }
  return cleanup(props);
}
function select(config, options) {
  return cleanup(_rollupPluginBabelHelpers.objectSpread2(_rollupPluginBabelHelpers.objectSpread2({}, getFormControlProps(config, options)), {}, {
    defaultValue: config.defaultValue,
    multiple: config.multiple
  }));
}
function textarea(config, options) {
  return cleanup(_rollupPluginBabelHelpers.objectSpread2(_rollupPluginBabelHelpers.objectSpread2({}, getFormControlProps(config, options)), {}, {
    defaultValue: config.defaultValue,
    minLength: config.minLength,
    maxLength: config.maxLength
  }));
}
function fieldset(config, options) {
  return getFormElementProps(config, options);
}
function collection(config, options) {
  return options.options.map(value => cleanup(_rollupPluginBabelHelpers.objectSpread2(_rollupPluginBabelHelpers.objectSpread2({}, getFormControlProps(config, options)), {}, {
    id: config.id ? "".concat(config.id, "-").concat(value) : undefined,
    type: options.type,
    value,
    defaultChecked: options.type === 'checkbox' && Array.isArray(config.defaultValue) ? config.defaultValue.includes(value) : config.defaultValue === value,
    // The required attribute doesn't make sense for checkbox group
    // As it would require all checkboxes to be checked instead of at least one
    // overriden with `undefiend` so it gets cleaned up
    required: options.type === 'checkbox' ? undefined : config.required
  })));
}

Object.defineProperty(exports, 'INTENT', {
	enumerable: true,
	get: function () { return dom.INTENT; }
});
Object.defineProperty(exports, 'VALIDATION_SKIPPED', {
	enumerable: true,
	get: function () { return dom.VALIDATION_SKIPPED; }
});
Object.defineProperty(exports, 'VALIDATION_UNDEFINED', {
	enumerable: true,
	get: function () { return dom.VALIDATION_UNDEFINED; }
});
exports.collection = collection;
exports.fieldset = fieldset;
exports.hiddenProps = hiddenProps;
exports.input = input;
exports.select = select;
exports.textarea = textarea;
