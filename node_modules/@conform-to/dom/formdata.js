'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * A ponyfill-like helper to get the form data with the submitter value.
 * It does not respect the tree order nor handles the image input.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/FormData/FormData#parameters
 */

function getFormData(form, submitter) {
  var payload = new FormData(form);
  if (submitter && submitter.type === 'submit' && submitter.name !== '') {
    payload.append(submitter.name, submitter.value);
  }
  return payload;
}

/**
 * Returns the paths from a name based on the JS syntax convention
 * @example
 * ```js
 * const paths = getPaths('todos[0].content'); // ['todos', 0, 'content']
 * ```
 */
function getPaths(name) {
  if (!name) {
    return [];
  }
  return name.split(/\.|(\[\d*\])/).reduce((result, segment) => {
    if (typeof segment !== 'undefined' && segment !== '') {
      if (segment.startsWith('[') && segment.endsWith(']')) {
        var index = segment.slice(1, -1);
        result.push(Number(index));
      } else {
        result.push(segment);
      }
    }
    return result;
  }, []);
}

/**
 * Returns a formatted name from the paths based on the JS syntax convention
 * @example
 * ```js
 * const name = formatPaths(['todos', 0, 'content']); // "todos[0].content"
 * ```
 */
function formatPaths(paths) {
  return paths.reduce((name, path) => {
    if (typeof path === 'number') {
      return "".concat(name, "[").concat(path, "]");
    }
    if (name === '' || path === '') {
      return [name, path].join('');
    }
    return [name, path].join('.');
  }, '');
}

/**
 * Assign a value to a target object by following the paths on the name
 */
function setValue(target, name, valueFn) {
  var paths = getPaths(name);
  var length = paths.length;
  var lastIndex = length - 1;
  var index = -1;
  var pointer = target;
  while (pointer != null && ++index < length) {
    var _pointer$key;
    var key = paths[index];
    var nextKey = paths[index + 1];
    var newValue = index != lastIndex ? (_pointer$key = pointer[key]) !== null && _pointer$key !== void 0 ? _pointer$key : typeof nextKey === 'number' ? [] : {} : valueFn(pointer[key]);
    pointer[key] = newValue;
    pointer = pointer[key];
  }
}

/**
 * Resolves the payload into a plain object based on the JS syntax convention
 */
function resolve(payload) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var data = {};
  var _loop = function _loop(value) {
    var _options$ignoreKeys;
    if ((_options$ignoreKeys = options.ignoreKeys) !== null && _options$ignoreKeys !== void 0 && _options$ignoreKeys.includes(key)) {
      return "continue";
    }
    setValue(data, key, prev => {
      if (!prev) {
        return value;
      } else if (Array.isArray(prev)) {
        return prev.concat(value);
      } else {
        return [prev, value];
      }
    });
  };
  for (var [key, value] of payload.entries()) {
    var _ret = _loop(value);
    if (_ret === "continue") continue;
  }
  return data;
}

/**
 * Format the error messages into a validation message
 */
function getValidationMessage(errors) {
  var _errors$join;
  return (_errors$join = errors === null || errors === void 0 ? void 0 : errors.join(String.fromCharCode(31))) !== null && _errors$join !== void 0 ? _errors$join : '';
}

/**
 * Retrieve the error messages from the validation message
 */
function getErrors(validationMessage) {
  // Empty string should be considered no error as well
  if (!validationMessage) {
    return [];
  }
  return validationMessage.split(String.fromCharCode(31));
}

exports.formatPaths = formatPaths;
exports.getErrors = getErrors;
exports.getFormData = getFormData;
exports.getPaths = getPaths;
exports.getValidationMessage = getValidationMessage;
exports.resolve = resolve;
exports.setValue = setValue;
