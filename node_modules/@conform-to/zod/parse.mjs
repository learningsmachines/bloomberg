import { parse as parse$1, VALIDATION_SKIPPED, VALIDATION_UNDEFINED, getName } from '@conform-to/dom';
import { ZodIssueCode } from 'zod';
import { enableTypeCoercion } from './coercion.mjs';

function parse(payload, config) {
  return parse$1(payload, {
    resolve(payload, intent) {
      var schema = enableTypeCoercion(typeof config.schema === 'function' ? config.schema(intent) : config.schema);
      var resolveResult = result => {
        if (result.success) {
          return {
            value: result.data
          };
        }
        return {
          error: result.error.errors.reduce((result, e) => {
            var _result$name;
            var name = getName(e.path);
            result[name] = [...((_result$name = result[name]) !== null && _result$name !== void 0 ? _result$name : []), e.message];
            return result;
          }, {})
        };
      };
      return config.async ? schema.safeParseAsync(payload, {
        errorMap: config.errorMap
      }).then(resolveResult) : resolveResult(schema.safeParse(payload, {
        errorMap: config.errorMap
      }));
    }
  });
}

/**
 * A helper function to define a custom constraint on a superRefine check.
 * Mainly used for async validation.
 *
 * @see https://conform.guide/api/zod#refine
 */
function refine(ctx, options) {
  if (typeof options.when !== 'undefined' && !options.when) {
    ctx.addIssue({
      code: ZodIssueCode.custom,
      message: VALIDATION_SKIPPED,
      path: options.path
    });
    return;
  }

  // Run the validation
  var result = options.validate();
  if (typeof result === 'undefined') {
    // Validate only if the constraint is defined
    ctx.addIssue({
      code: ZodIssueCode.custom,
      message: VALIDATION_UNDEFINED,
      path: options.path
    });
    return;
  }
  var reportInvalid = valid => {
    if (valid) {
      return;
    }
    ctx.addIssue({
      code: ZodIssueCode.custom,
      message: options.message,
      path: options.path,
      params: options.params
    });
  };
  return typeof result === 'boolean' ? reportInvalid(result) : result.then(reportInvalid);
}

export { parse, refine };
