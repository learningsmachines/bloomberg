'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var dom = require('@conform-to/dom');
var zod = require('zod');
var coercion = require('./coercion.js');

function parse(payload, config) {
  return dom.parse(payload, {
    resolve(payload, intent) {
      var schema = coercion.enableTypeCoercion(typeof config.schema === 'function' ? config.schema(intent) : config.schema);
      var resolveResult = result => {
        if (result.success) {
          return {
            value: result.data
          };
        }
        return {
          error: result.error.errors.reduce((result, e) => {
            var _result$name;
            var name = dom.getName(e.path);
            result[name] = [...((_result$name = result[name]) !== null && _result$name !== void 0 ? _result$name : []), e.message];
            return result;
          }, {})
        };
      };
      return config.async ? schema.safeParseAsync(payload, {
        errorMap: config.errorMap
      }).then(resolveResult) : resolveResult(schema.safeParse(payload, {
        errorMap: config.errorMap
      }));
    }
  });
}

/**
 * A helper function to define a custom constraint on a superRefine check.
 * Mainly used for async validation.
 *
 * @see https://conform.guide/api/zod#refine
 */
function refine(ctx, options) {
  if (typeof options.when !== 'undefined' && !options.when) {
    ctx.addIssue({
      code: zod.ZodIssueCode.custom,
      message: dom.VALIDATION_SKIPPED,
      path: options.path
    });
    return;
  }

  // Run the validation
  var result = options.validate();
  if (typeof result === 'undefined') {
    // Validate only if the constraint is defined
    ctx.addIssue({
      code: zod.ZodIssueCode.custom,
      message: dom.VALIDATION_UNDEFINED,
      path: options.path
    });
    return;
  }
  var reportInvalid = valid => {
    if (valid) {
      return;
    }
    ctx.addIssue({
      code: zod.ZodIssueCode.custom,
      message: options.message,
      path: options.path,
      params: options.params
    });
  };
  return typeof result === 'boolean' ? reportInvalid(result) : result.then(reportInvalid);
}

exports.parse = parse;
exports.refine = refine;
