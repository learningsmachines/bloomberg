"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  assertCacheEntry: () => assertCacheEntry,
  cachified: () => cachified,
  createBatch: () => createBatch,
  createCacheEntry: () => createCacheEntry,
  default: () => cachified,
  lruCacheAdapter: () => lruCacheAdapter,
  mergeReporters: () => mergeReporters,
  redis3CacheAdapter: () => redis3CacheAdapter,
  redisCacheAdapter: () => redisCacheAdapter,
  shouldRefresh: () => shouldRefresh,
  softPurge: () => softPurge,
  staleWhileRevalidate: () => staleWhileRevalidate,
  totalTtl: () => totalTtl,
  verboseReporter: () => verboseReporter
});
module.exports = __toCommonJS(src_exports);

// src/common.ts
var HANDLE = Symbol();
var MIGRATED = Symbol();
function createContext(_a) {
  var _b = _a, {
    fallbackToCache,
    reporter,
    checkValue: checkValue2
  } = _b, options = __objRest(_b, [
    "fallbackToCache",
    "reporter",
    "checkValue"
  ]);
  var _a2, _b2, _c;
  const ttl = (_a2 = options.ttl) != null ? _a2 : Infinity;
  const staleWhileRevalidate2 = (_c = (_b2 = options.swr) != null ? _b2 : options.staleWhileRevalidate) != null ? _c : 0;
  const checkValueCompat = typeof checkValue2 === "function" ? checkValue2 : typeof checkValue2 === "object" ? (value, migrate) => checkValue2.parseAsync(value).then((v) => migrate(v, false)) : () => true;
  const contextWithoutReport = __spreadProps(__spreadValues({
    checkValue: checkValueCompat,
    ttl,
    staleWhileRevalidate: staleWhileRevalidate2,
    fallbackToCache: fallbackToCache === false ? 0 : fallbackToCache === true || fallbackToCache === void 0 ? Infinity : fallbackToCache,
    staleRefreshTimeout: 0,
    forceFresh: false
  }, options), {
    metadata: createCacheMetaData({ ttl, swr: staleWhileRevalidate2 })
  });
  const report = (reporter == null ? void 0 : reporter(contextWithoutReport)) || (() => {
  });
  return __spreadProps(__spreadValues({}, contextWithoutReport), {
    report
  });
}
function staleWhileRevalidate(metadata) {
  return (typeof metadata.swr === "undefined" ? metadata.swv : metadata.swr) || null;
}
function totalTtl(metadata) {
  if (!metadata) {
    return 0;
  }
  if (metadata.ttl === null) {
    return Infinity;
  }
  return (metadata.ttl || 0) + (staleWhileRevalidate(metadata) || 0);
}
function createCacheMetaData({
  ttl = null,
  swr = 0,
  createdTime = Date.now()
} = {}) {
  return {
    ttl: ttl === Infinity ? null : ttl,
    swr: swr === Infinity ? null : swr,
    createdTime
  };
}
function createCacheEntry(value, metadata) {
  return {
    value,
    metadata: createCacheMetaData(metadata)
  };
}

// src/reporter.ts
var defaultFormatDuration = (ms) => `${Math.round(ms)}ms`;
function formatCacheTime(metadata, formatDuration) {
  const swr = staleWhileRevalidate(metadata);
  if (metadata.ttl == null || swr == null) {
    return `forever${metadata.ttl != null ? ` (revalidation after ${formatDuration(metadata.ttl)})` : ""}`;
  }
  return `${formatDuration(metadata.ttl)} + ${formatDuration(swr)} stale`;
}
function verboseReporter({
  formatDuration = defaultFormatDuration,
  logger = console,
  performance = global.performance || Date
} = {}) {
  return ({ key, fallbackToCache, forceFresh, metadata, cache }) => {
    const cacheName = cache.name || cache.toString().toString().replace(/^\[object (.*?)]$/, "$1");
    let cached;
    let freshValue;
    let getFreshValueStartTs;
    let refreshValueStartTS;
    return (event) => {
      switch (event.name) {
        case "getCachedValueRead":
          cached = event.entry;
          break;
        case "checkCachedValueError":
          logger.warn(
            `check failed for cached value of ${key}
Reason: ${event.reason}.
Deleting the cache key and trying to get a fresh value.`,
            cached
          );
          break;
        case "getCachedValueError":
          logger.error(
            `error with cache at ${key}. Deleting the cache key and trying to get a fresh value.`,
            event.error
          );
          break;
        case "getFreshValueError":
          logger.error(
            `getting a fresh value for ${key} failed`,
            { fallbackToCache, forceFresh },
            event.error
          );
          break;
        case "getFreshValueStart":
          getFreshValueStartTs = performance.now();
          break;
        case "writeFreshValueSuccess": {
          const totalTime = performance.now() - getFreshValueStartTs;
          if (event.written) {
            logger.log(
              `Updated the cache value for ${key}.`,
              `Getting a fresh value for this took ${formatDuration(
                totalTime
              )}.`,
              `Caching for ${formatCacheTime(
                metadata,
                formatDuration
              )} in ${cacheName}.`
            );
          } else {
            logger.log(
              `Not updating the cache value for ${key}.`,
              `Getting a fresh value for this took ${formatDuration(
                totalTime
              )}.`,
              `Thereby exceeding caching time of ${formatCacheTime(
                metadata,
                formatDuration
              )}`
            );
          }
          break;
        }
        case "writeFreshValueError":
          logger.error(`error setting cache: ${key}`, event.error);
          break;
        case "getFreshValueSuccess":
          freshValue = event.value;
          break;
        case "checkFreshValueError":
          logger.error(
            `check failed for fresh value of ${key}
Reason: ${event.reason}.`,
            freshValue
          );
          break;
        case "refreshValueStart":
          refreshValueStartTS = performance.now();
          break;
        case "refreshValueSuccess":
          logger.log(
            `Background refresh for ${key} successful.`,
            `Getting a fresh value for this took ${formatDuration(
              performance.now() - refreshValueStartTS
            )}.`,
            `Caching for ${formatCacheTime(
              metadata,
              formatDuration
            )} in ${cacheName}.`
          );
          break;
        case "refreshValueError":
          logger.log(`Background refresh for ${key} failed.`, event.error);
          break;
      }
    };
  };
}
function mergeReporters(...reporters) {
  return (context) => {
    const reporter = reporters.map((r) => r == null ? void 0 : r(context));
    return (event) => {
      reporter.forEach((r) => r == null ? void 0 : r(event));
    };
  };
}

// src/adapters.ts
function lruCacheAdapter(lruCache) {
  return {
    name: lruCache.name || "LRU",
    set(key, value) {
      var _a;
      const ttl = totalTtl(value == null ? void 0 : value.metadata);
      return lruCache.set(key, value, {
        ttl: ttl === Infinity ? void 0 : ttl,
        start: (_a = value == null ? void 0 : value.metadata) == null ? void 0 : _a.createdTime
      });
    },
    get(key) {
      return lruCache.get(key);
    },
    delete(key) {
      return lruCache.delete(key);
    }
  };
}
function redis3CacheAdapter(redisCache) {
  return {
    name: redisCache.name || "Redis3",
    set(key, value) {
      return new Promise((res, rej) => {
        var _a;
        const ttl = totalTtl(value == null ? void 0 : value.metadata);
        const createdTime = (_a = value == null ? void 0 : value.metadata) == null ? void 0 : _a.createdTime;
        const cb = (err) => {
          if (err) {
            return rej(err);
          }
          res();
        };
        if (ttl > 0 && ttl < Infinity && typeof createdTime === "number") {
          redisCache.multi().set(key, JSON.stringify(value)).expireat(key, (ttl + createdTime) / 1e3).exec(cb);
        } else {
          redisCache.set(key, JSON.stringify(value), cb);
        }
      });
    },
    get(key) {
      return new Promise((res, rej) => {
        redisCache.get(key, (err, reply) => {
          if (err) {
            rej(err);
          } else if (reply == null) {
            res(null);
          } else {
            try {
              res(JSON.parse(reply));
            } catch (err2) {
              rej(err2);
            }
          }
        });
      });
    },
    delete(key) {
      return new Promise((res, rej) => {
        redisCache.del(key, (err) => {
          if (err) {
            rej(err);
          }
          res();
        });
      });
    }
  };
}
function redisCacheAdapter(redisCache) {
  return {
    name: redisCache.name || "Redis",
    set(key, value) {
      var _a2;
      const ttl = totalTtl(value == null ? void 0 : value.metadata);
      const createdTime = (_a2 = value == null ? void 0 : value.metadata) == null ? void 0 : _a2.createdTime;
      return redisCache.set(
        key,
        JSON.stringify(value),
        ttl > 0 && ttl < Infinity && typeof createdTime === "number" ? {
          EXAT: Math.ceil((ttl + createdTime) / 1e3)
        } : void 0
      );
    },
    get(key) {
      return __async(this, null, function* () {
        const value = yield redisCache.get(key);
        if (value == null) {
          return null;
        }
        return JSON.parse(value);
      });
    },
    delete(key) {
      return redisCache.del(key);
    }
  };
}

// src/createBatch.ts
function createBatch(getFreshValues, autoSubmit = true) {
  const requests = [];
  let count = 0;
  let submitted = false;
  const submission = new Deferred();
  const checkSubmission = () => {
    if (submitted) {
      throw new Error("Can not add to batch after submission");
    }
  };
  const submit = () => __async(this, null, function* () {
    if (count !== 0) {
      autoSubmit = true;
      return submission.promise;
    }
    checkSubmission();
    submitted = true;
    if (requests.length === 0) {
      submission.resolve();
      return;
    }
    try {
      const results = yield Promise.resolve(
        getFreshValues(requests.map(([param]) => param))
      );
      results.forEach((value, index) => requests[index][1](value));
      submission.resolve();
    } catch (err) {
      requests.forEach(([_, __, rej]) => rej(err));
      submission.resolve();
    }
  });
  const trySubmitting = () => {
    count--;
    if (autoSubmit === false) {
      return;
    }
    submit();
  };
  return __spreadProps(__spreadValues({}, autoSubmit === false ? { submit } : {}), {
    add(param, onValue) {
      checkSubmission();
      count++;
      let handled = false;
      return Object.assign(
        (context) => {
          return new Promise((res, rej) => {
            requests.push([
              param,
              (value) => {
                onValue == null ? void 0 : onValue(__spreadProps(__spreadValues({}, context), { value }));
                res(value);
              },
              rej
            ]);
            if (!handled) {
              handled = true;
              trySubmitting();
            }
          });
        },
        {
          [HANDLE]: () => {
            if (!handled) {
              handled = true;
              trySubmitting();
            }
          }
        }
      );
    }
  });
}
var Deferred = class {
  constructor() {
    this.promise = new Promise((res, rej) => {
      this.resolve = res;
      this.reject = rej;
    });
  }
};

// src/assertCacheEntry.ts
function logKey(key) {
  return key ? `for ${key} ` : "";
}
function assertCacheEntry(entry, key) {
  if (!isRecord(entry)) {
    throw new Error(
      `Cache entry ${logKey(
        key
      )}is not a cache entry object, it's a ${typeof entry}`
    );
  }
  if (!isRecord(entry.metadata) || typeof entry.metadata.createdTime !== "number" || entry.metadata.ttl != null && typeof entry.metadata.ttl !== "number" || entry.metadata.swr != null && typeof entry.metadata.swr !== "number") {
    throw new Error(
      `Cache entry ${logKey(key)}does not have valid metadata property`
    );
  }
  if (!("value" in entry)) {
    throw new Error(
      `Cache entry for ${logKey(key)}does not have a value property`
    );
  }
}
function isRecord(entry) {
  return typeof entry === "object" && entry !== null && !Array.isArray(entry);
}

// src/shouldRefresh.ts
function shouldRefresh(metadata) {
  if (metadata.ttl !== null) {
    const valid = metadata.createdTime + (metadata.ttl || 0);
    const stale = valid + (staleWhileRevalidate(metadata) || 0);
    const now = Date.now();
    if (now <= valid) {
      return false;
    }
    if (now <= stale) {
      return "stale";
    }
    return "now";
  }
  return false;
}

// src/checkValue.ts
function checkValue(context, value) {
  return __async(this, null, function* () {
    try {
      const checkResponse = yield context.checkValue(
        value,
        (value2, updateCache = true) => ({
          [MIGRATED]: updateCache,
          value: value2
        })
      );
      if (typeof checkResponse === "string") {
        return { success: false, reason: checkResponse };
      }
      if (checkResponse == null || checkResponse === true) {
        return {
          success: true,
          value,
          migrated: false
        };
      }
      if (checkResponse && typeof checkResponse[MIGRATED] === "boolean") {
        return {
          success: true,
          migrated: checkResponse[MIGRATED],
          value: checkResponse.value
        };
      }
      return { success: false, reason: "unknown" };
    } catch (err) {
      return {
        success: false,
        reason: err
      };
    }
  });
}

// src/getCachedValue.ts
var CACHE_EMPTY = Symbol();
function getCacheEntry(_0, _1) {
  return __async(this, arguments, function* ({ key, cache }, report) {
    report({ name: "getCachedValueStart" });
    const cached = yield cache.get(key);
    report({ name: "getCachedValueRead", entry: cached });
    if (cached) {
      assertCacheEntry(cached, key);
      return cached;
    }
    return CACHE_EMPTY;
  });
}
function getCachedValue(context, report, hasPendingValue) {
  return __async(this, null, function* () {
    const {
      key,
      cache,
      staleWhileRevalidate: staleWhileRevalidate2,
      staleRefreshTimeout,
      metadata,
      getFreshValue: { [HANDLE]: handle }
    } = context;
    try {
      const cached = yield getCacheEntry(context, report);
      if (cached === CACHE_EMPTY) {
        report({ name: "getCachedValueEmpty" });
        return CACHE_EMPTY;
      }
      const refresh = shouldRefresh(cached.metadata);
      const staleRefresh = refresh === "stale" || refresh === "now" && staleWhileRevalidate2 === Infinity;
      if (refresh === "now") {
        report(__spreadValues({ name: "getCachedValueOutdated" }, cached));
      }
      if (staleRefresh) {
        setTimeout(() => {
          report({ name: "refreshValueStart" });
          void cachified(__spreadProps(__spreadValues({}, context), {
            reporter: () => () => {
            },
            getFreshValue({ metadata: metadata2 }) {
              return context.getFreshValue({ metadata: metadata2, background: true });
            },
            forceFresh: true,
            fallbackToCache: false
          })).then((value) => {
            report({ name: "refreshValueSuccess", value });
          }).catch((error) => {
            report({ name: "refreshValueError", error });
          });
        }, staleRefreshTimeout);
      }
      if (!refresh || staleRefresh) {
        const valueCheck = yield checkValue(context, cached.value);
        if (valueCheck.success) {
          report({
            name: "getCachedValueSuccess",
            value: valueCheck.value,
            migrated: valueCheck.migrated
          });
          if (!staleRefresh) {
            handle == null ? void 0 : handle();
          }
          if (valueCheck.migrated) {
            setTimeout(() => __async(this, null, function* () {
              try {
                const cached2 = yield context.cache.get(context.key);
                if (cached2 && cached2.metadata.createdTime === metadata.createdTime && !hasPendingValue()) {
                  yield context.cache.set(context.key, __spreadProps(__spreadValues({}, cached2), {
                    value: valueCheck.value
                  }));
                }
              } catch (err) {
              }
            }), 0);
          }
          return valueCheck.value;
        } else {
          report({ name: "checkCachedValueErrorObj", reason: valueCheck.reason });
          report({
            name: "checkCachedValueError",
            reason: valueCheck.reason instanceof Error ? valueCheck.reason.message : String(valueCheck.reason)
          });
          yield cache.delete(key);
        }
      }
    } catch (error) {
      report({ name: "getCachedValueError", error });
      yield cache.delete(key);
    }
    return CACHE_EMPTY;
  });
}

// src/getFreshValue.ts
function getFreshValue(context, metadata, report) {
  return __async(this, null, function* () {
    const { fallbackToCache, key, getFreshValue: getFreshValue2, forceFresh, cache } = context;
    let value;
    try {
      report({ name: "getFreshValueStart" });
      const freshValue = yield getFreshValue2({
        metadata: context.metadata,
        background: false
      });
      value = freshValue;
      report({ name: "getFreshValueSuccess", value: freshValue });
    } catch (error) {
      report({ name: "getFreshValueError", error });
      if (forceFresh && fallbackToCache > 0) {
        const entry = yield getCacheEntry(context, report);
        if (entry === CACHE_EMPTY || entry.metadata.createdTime + fallbackToCache < Date.now()) {
          throw error;
        }
        value = entry.value;
        report({ name: "getFreshValueCacheFallback", value });
      } else {
        throw error;
      }
    }
    const valueCheck = yield checkValue(context, value);
    if (!valueCheck.success) {
      report({ name: "checkFreshValueErrorObj", reason: valueCheck.reason });
      report({
        name: "checkFreshValueError",
        reason: valueCheck.reason instanceof Error ? valueCheck.reason.message : String(valueCheck.reason)
      });
      throw new Error(`check failed for fresh value of ${key}`, {
        cause: valueCheck.reason
      });
    }
    try {
      const write = shouldRefresh(metadata) !== "now";
      if (write) {
        yield cache.set(key, createCacheEntry(value, metadata));
      }
      report({
        name: "writeFreshValueSuccess",
        metadata,
        migrated: valueCheck.migrated,
        written: write
      });
    } catch (error) {
      report({ name: "writeFreshValueError", error });
    }
    return valueCheck.value;
  });
}

// src/cachified.ts
var pendingValuesByCache = /* @__PURE__ */ new WeakMap();
function cachified(options) {
  return __async(this, null, function* () {
    const context = createContext(options);
    const { key, cache, forceFresh, report, metadata } = context;
    if (!pendingValuesByCache.has(cache)) {
      pendingValuesByCache.set(cache, /* @__PURE__ */ new Map());
    }
    const pendingValues = pendingValuesByCache.get(cache);
    const hasPendingValue = () => {
      return pendingValues.has(key);
    };
    const cachedValue = !forceFresh ? yield getCachedValue(context, report, hasPendingValue) : CACHE_EMPTY;
    if (cachedValue !== CACHE_EMPTY) {
      report({ name: "done", value: cachedValue });
      return cachedValue;
    }
    if (pendingValues.has(key)) {
      const { value: pendingRefreshValue, metadata: metadata2 } = pendingValues.get(key);
      if (!shouldRefresh(metadata2)) {
        report({ name: "getFreshValueHookPending" });
        const value2 = yield pendingRefreshValue;
        report({ name: "done", value: value2 });
        return value2;
      }
    }
    let resolveFromFuture;
    const freshValue = Promise.race([
      // try to get a fresh value
      getFreshValue(context, metadata, report),
      // or when a future call is faster, we'll take it's value
      // this happens when getting value of first call takes longer then ttl + second response
      new Promise((r) => {
        resolveFromFuture = r;
      })
    ]).finally(() => {
      pendingValues.delete(key);
    });
    if (pendingValues.has(key)) {
      const { resolve } = pendingValues.get(key);
      freshValue.then((value2) => resolve(value2));
    }
    pendingValues.set(key, {
      metadata,
      value: freshValue,
      // here we receive a fresh value from a future call
      resolve: resolveFromFuture
    });
    const value = yield freshValue;
    report({ name: "done", value });
    return value;
  });
}

// src/softPurge.ts
function softPurge(_a) {
  return __async(this, null, function* () {
    var _b = _a, {
      cache,
      key
    } = _b, swrOverwrites = __objRest(_b, [
      "cache",
      "key"
    ]);
    var _a2;
    const swrOverwrite = (_a2 = swrOverwrites.swr) != null ? _a2 : swrOverwrites.staleWhileRevalidate;
    const entry = yield getCacheEntry({ cache, key }, () => {
    });
    if (entry === CACHE_EMPTY || shouldRefresh(entry.metadata)) {
      return;
    }
    const ttl = entry.metadata.ttl || Infinity;
    const swr = staleWhileRevalidate(entry.metadata) || 0;
    const lt = Date.now() - entry.metadata.createdTime;
    yield cache.set(
      key,
      createCacheEntry(entry.value, {
        ttl: 0,
        swr: swrOverwrite === void 0 ? ttl + swr : swrOverwrite + lt,
        createdTime: entry.metadata.createdTime
      })
    );
  });
}
//# sourceMappingURL=index.cjs.map
