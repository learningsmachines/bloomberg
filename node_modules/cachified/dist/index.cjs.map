{
  "version": 3,
  "sources": ["../src/index.ts", "../src/common.ts", "../src/reporter.ts", "../src/adapters.ts", "../src/createBatch.ts", "../src/assertCacheEntry.ts", "../src/shouldRefresh.ts", "../src/checkValue.ts", "../src/getCachedValue.ts", "../src/getFreshValue.ts", "../src/cachified.ts", "../src/softPurge.ts"],
  "sourcesContent": ["export type {\n  CachifiedOptions,\n  Cache,\n  CacheEntry,\n  CacheMetadata,\n  Context,\n  GetFreshValue,\n  GetFreshValueContext,\n} from './common';\nexport { staleWhileRevalidate, totalTtl, createCacheEntry } from './common';\nexport * from './reporter';\nexport * from './adapters';\nexport { createBatch } from './createBatch';\nexport { cachified } from './cachified';\nexport { cachified as default } from './cachified';\nexport { shouldRefresh } from './shouldRefresh';\nexport { assertCacheEntry } from './assertCacheEntry';\nexport { softPurge } from './softPurge';\n", "import type { CreateReporter, Reporter } from './reporter';\n\nexport interface CacheMetadata {\n  createdTime: number;\n  ttl?: number | null;\n  swr?: number | null;\n  /** @deprecated use swr instead */\n  readonly swv?: number | null;\n}\n\nexport interface CacheEntry<Value = unknown> {\n  metadata: CacheMetadata;\n  value: Value;\n}\n\nexport type Eventually<Value> =\n  | Value\n  | null\n  | undefined\n  | Promise<Value | null | undefined>;\n\nexport interface Cache {\n  name?: string;\n  get: (key: string) => Eventually<CacheEntry<unknown>>;\n  set: (key: string, value: CacheEntry<unknown>) => unknown | Promise<unknown>;\n  delete: (key: string) => unknown | Promise<unknown>;\n}\n\nexport interface GetFreshValueContext {\n  readonly metadata: CacheMetadata;\n  readonly background: boolean;\n}\nexport const HANDLE = Symbol();\nexport type GetFreshValue<Value> = {\n  (context: GetFreshValueContext): Promise<Value> | Value;\n  [HANDLE]?: () => void;\n};\nexport const MIGRATED = Symbol();\nexport type MigratedValue<Value> = {\n  [MIGRATED]: boolean;\n  value: Value;\n};\n\nexport type ValueCheckResultOk<Value> =\n  | true\n  | undefined\n  | null\n  | void\n  | MigratedValue<Value>;\nexport type ValueCheckResultInvalid = false | string;\nexport type ValueCheckResult<Value> =\n  | ValueCheckResultOk<Value>\n  | ValueCheckResultInvalid;\nexport type CheckValue<Value> = (\n  value: unknown,\n  migrate: (value: Value, updateCache?: boolean) => MigratedValue<Value>,\n) => ValueCheckResult<Value> | Promise<ValueCheckResult<Value>>;\nexport interface Schema<Value, InputValue> {\n  _input: InputValue;\n  parseAsync(value: unknown): Promise<Value>;\n}\n\nexport interface CachifiedOptions<Value> {\n  /**\n   * Required\n   *\n   * The key this value is cached by\n   * Must be unique for each value\n   */\n  key: string;\n  /**\n   * Required\n   *\n   * Cache implementation to use\n   *\n   * Must conform with signature\n   *  - set(key: string, value: object): void | Promise<void>\n   *  - get(key: string): object | Promise<object>\n   *  - delete(key: string): void | Promise<void>\n   */\n  cache: Cache;\n  /**\n   * Required\n   *\n   * Function that is called when no valid value is in cache for given key\n   * Basically what we would do if we wouldn't use a cache\n   *\n   * Can be async and must return fresh value or throw\n   *\n   * receives context object as argument\n   *  - context.metadata.ttl?: number\n   *  - context.metadata.swr?: number\n   *  - context.metadata.createdTime: number\n   *  - context.background: boolean\n   */\n  getFreshValue: GetFreshValue<Value>;\n  /**\n   * Time To Live; often also referred to as max age\n   *\n   * Amount of milliseconds the value should stay in cache\n   * before we get a fresh one\n   *\n   * Setting any negative value will disable caching\n   * Can be infinite\n   *\n   * Default: `Infinity`\n   */\n  ttl?: number;\n  /**\n   * Amount of milliseconds that a value with exceeded ttl is still returned\n   * while a fresh value is refreshed in the background\n   *\n   * Should be positive, can be infinite\n   *\n   * Default: `0`\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Alias for staleWhileRevalidate\n   */\n  swr?: number;\n  /**\n   * Validator that checks every cached and fresh value to ensure type safety\n   *\n   * Can be a zod schema or a custom validator function\n   *\n   * Value considered ok when:\n   *  - zod schema.parseAsync succeeds\n   *  - validator returns\n   *    - true\n   *    - migrate(newValue)\n   *    - undefined\n   *    - null\n   *\n   * Value considered bad when:\n   *  - zod schema.parseAsync throws\n   *  - validator:\n   *    - returns false\n   *    - returns reason as string\n   *    - throws\n   *\n   * A validator function receives two arguments:\n   *  1. the value\n   *  2. a migrate callback, see https://github.com/Xiphe/cachified#migrating-values\n   *\n   * Default: `undefined` - no validation\n   */\n  checkValue?: CheckValue<Value> | Schema<Value, unknown>;\n  /**\n   * Set true to not even try reading the currently cached value\n   *\n   * Will write new value to cache even when cached value is\n   * still valid.\n   *\n   * Default: `false`\n   */\n  forceFresh?: boolean;\n  /**\n   * Weather of not to fall back to cache when getting a forced fresh value\n   * fails\n   *\n   * Can also be a positive number as the maximum age in milliseconds that a\n   * fallback value might have\n   *\n   * Default: `Infinity`\n   */\n  fallbackToCache?: boolean | number;\n  /**\n   * Amount of time in milliseconds before revalidation of a stale\n   * cache entry is started\n   *\n   * Must be positive and finite\n   *\n   * Default: `0`\n   */\n  staleRefreshTimeout?: number;\n  /**\n   * A reporter receives events during the runtime of\n   * cachified and can be used for debugging and monitoring\n   *\n   * Default: `undefined` - no reporting\n   */\n  reporter?: CreateReporter<Value> | null;\n}\n\n/* When using a schema validator, a strongly typed getFreshValue is not required\n   and sometimes even sub-optimal */\nexport type CachifiedOptionsWithSchema<Value, InternalValue> = Omit<\n  CachifiedOptions<Value>,\n  'checkValue' | 'getFreshValue'\n> & {\n  checkValue: Schema<Value, InternalValue>;\n  getFreshValue: GetFreshValue<InternalValue>;\n};\n\nexport interface Context<Value>\n  extends Omit<\n    Required<CachifiedOptions<Value>>,\n    'fallbackToCache' | 'reporter' | 'checkValue' | 'swr'\n  > {\n  checkValue: CheckValue<Value>;\n  report: Reporter<Value>;\n  fallbackToCache: number;\n  metadata: CacheMetadata;\n}\n\nexport function createContext<Value>({\n  fallbackToCache,\n  reporter,\n  checkValue,\n  ...options\n}: CachifiedOptions<Value>): Context<Value> {\n  const ttl = options.ttl ?? Infinity;\n  const staleWhileRevalidate = options.swr ?? options.staleWhileRevalidate ?? 0;\n  const checkValueCompat: CheckValue<Value> =\n    typeof checkValue === 'function'\n      ? checkValue\n      : typeof checkValue === 'object'\n      ? (value, migrate) =>\n          checkValue.parseAsync(value).then((v) => migrate(v, false))\n      : () => true;\n\n  const contextWithoutReport = {\n    checkValue: checkValueCompat,\n    ttl,\n    staleWhileRevalidate,\n    fallbackToCache:\n      fallbackToCache === false\n        ? 0\n        : fallbackToCache === true || fallbackToCache === undefined\n        ? Infinity\n        : fallbackToCache,\n    staleRefreshTimeout: 0,\n    forceFresh: false,\n    ...options,\n    metadata: createCacheMetaData({ ttl, swr: staleWhileRevalidate }),\n  };\n\n  const report =\n    reporter?.(contextWithoutReport) ||\n    (() => {\n      /* \u00AF\\_(\u30C4)_/\u00AF */\n    });\n\n  return {\n    ...contextWithoutReport,\n    report,\n  };\n}\n\nexport function staleWhileRevalidate(metadata: CacheMetadata): number | null {\n  return (\n    (typeof metadata.swr === 'undefined' ? metadata.swv : metadata.swr) || null\n  );\n}\n\nexport function totalTtl(metadata?: CacheMetadata): number {\n  if (!metadata) {\n    return 0;\n  }\n  if (metadata.ttl === null) {\n    return Infinity;\n  }\n  return (metadata.ttl || 0) + (staleWhileRevalidate(metadata) || 0);\n}\n\nexport function createCacheMetaData({\n  ttl = null,\n  swr = 0,\n  createdTime = Date.now(),\n}: Partial<Omit<CacheMetadata, 'swv'>> = {}) {\n  return {\n    ttl: ttl === Infinity ? null : ttl,\n    swr: swr === Infinity ? null : swr,\n    createdTime,\n  };\n}\n\nexport function createCacheEntry<Value>(\n  value: Value,\n  metadata?: Partial<Omit<CacheMetadata, 'swv'>>,\n): CacheEntry<Value> {\n  return {\n    value,\n    metadata: createCacheMetaData(metadata),\n  };\n}\n", "import { CacheMetadata, Context, staleWhileRevalidate } from './common';\n\nexport type GetFreshValueStartEvent = {\n  name: 'getFreshValueStart';\n};\nexport type GetFreshValueHookPendingEvent = {\n  name: 'getFreshValueHookPending';\n};\nexport type GetFreshValueSuccessEvent<Value> = {\n  name: 'getFreshValueSuccess';\n  value: Value;\n};\nexport type GetFreshValueErrorEvent = {\n  name: 'getFreshValueError';\n  error: unknown;\n};\nexport type GetFreshValueCacheFallbackEvent = {\n  name: 'getFreshValueCacheFallback';\n  value: unknown;\n};\n/** @deprecated this event will be removed in favour of `CheckFreshValueErrorObjEvent` */\nexport type CheckFreshValueErrorEvent<Value> = {\n  name: 'checkFreshValueError';\n  reason: string;\n};\nexport type CheckFreshValueErrorObjEvent = {\n  name: 'checkFreshValueErrorObj';\n  reason: unknown;\n};\nexport type WriteFreshValueSuccessEvent<Value> = {\n  name: 'writeFreshValueSuccess';\n  metadata: CacheMetadata;\n  /**\n   * Value might not actually be written to cache in case getting fresh\n   * value took longer then ttl */\n  written: boolean;\n  migrated: boolean;\n};\nexport type WriteFreshValueErrorEvent = {\n  name: 'writeFreshValueError';\n  error: unknown;\n};\n\nexport type GetCachedValueStartEvent = {\n  name: 'getCachedValueStart';\n};\nexport type GetCachedValueReadEvent = {\n  name: 'getCachedValueRead';\n  entry: unknown;\n};\nexport type GetCachedValueEmptyEvent = {\n  name: 'getCachedValueEmpty';\n};\nexport type GetCachedValueOutdatedEvent = {\n  name: 'getCachedValueOutdated';\n  value: unknown;\n  metadata: CacheMetadata;\n};\nexport type GetCachedValueSuccessEvent<Value> = {\n  name: 'getCachedValueSuccess';\n  value: Value;\n  migrated: boolean;\n};\n/** @deprecated this event will be removed in favour of `CheckCachedValueErrorObjEvent` */\nexport type CheckCachedValueErrorEvent = {\n  name: 'checkCachedValueError';\n  reason: string;\n};\nexport type CheckCachedValueErrorObjEvent = {\n  name: 'checkCachedValueErrorObj';\n  reason: unknown;\n};\nexport type GetCachedValueErrorEvent = {\n  name: 'getCachedValueError';\n  error: unknown;\n};\n\nexport type RefreshValueStartEvent = {\n  name: 'refreshValueStart';\n};\nexport type RefreshValueSuccessEvent<Value> = {\n  name: 'refreshValueSuccess';\n  value: Value;\n};\nexport type RefreshValueErrorEvent = {\n  name: 'refreshValueError';\n  error: unknown;\n};\nexport type DoneEvent<Value> = {\n  name: 'done';\n  value: Value;\n};\n\nexport type CacheEvent<Value> =\n  | GetFreshValueStartEvent\n  | GetFreshValueHookPendingEvent\n  | GetFreshValueSuccessEvent<Value>\n  | GetFreshValueErrorEvent\n  | GetFreshValueCacheFallbackEvent\n  | CheckFreshValueErrorEvent<Value>\n  | CheckFreshValueErrorObjEvent\n  | WriteFreshValueSuccessEvent<Value>\n  | WriteFreshValueErrorEvent\n  | GetCachedValueStartEvent\n  | GetCachedValueReadEvent\n  | GetCachedValueEmptyEvent\n  | GetCachedValueOutdatedEvent\n  | GetCachedValueSuccessEvent<Value>\n  | CheckCachedValueErrorEvent\n  | CheckCachedValueErrorObjEvent\n  | GetCachedValueErrorEvent\n  | RefreshValueStartEvent\n  | RefreshValueSuccessEvent<Value>\n  | RefreshValueErrorEvent\n  | DoneEvent<Value>;\n\nexport type Reporter<Value> = (event: CacheEvent<Value>) => void;\n\nexport type CreateReporter<Value> = (\n  context: Omit<Context<Value>, 'report'>,\n) => Reporter<Value>;\n\nconst defaultFormatDuration = (ms: number) => `${Math.round(ms)}ms`;\nfunction formatCacheTime(\n  metadata: CacheMetadata,\n  formatDuration: (duration: number) => string,\n) {\n  const swr = staleWhileRevalidate(metadata);\n  if (metadata.ttl == null || swr == null) {\n    return `forever${\n      metadata.ttl != null\n        ? ` (revalidation after ${formatDuration(metadata.ttl)})`\n        : ''\n    }`;\n  }\n\n  return `${formatDuration(metadata.ttl)} + ${formatDuration(swr)} stale`;\n}\n\ninterface ReporterOpts {\n  formatDuration?: (ms: number) => string;\n  logger?: Pick<typeof console, 'log' | 'warn' | 'error'>;\n  performance?: Pick<typeof Date, 'now'>;\n}\nexport function verboseReporter<Value>({\n  formatDuration = defaultFormatDuration,\n  logger = console,\n  performance = global.performance || Date,\n}: ReporterOpts = {}): CreateReporter<Value> {\n  return ({ key, fallbackToCache, forceFresh, metadata, cache }) => {\n    const cacheName =\n      cache.name ||\n      cache\n        .toString()\n        .toString()\n        .replace(/^\\[object (.*?)]$/, '$1');\n    let cached: unknown;\n    let freshValue: unknown;\n    let getFreshValueStartTs: number;\n    let refreshValueStartTS: number;\n\n    return (event) => {\n      switch (event.name) {\n        case 'getCachedValueRead':\n          cached = event.entry;\n          break;\n        case 'checkCachedValueError':\n          logger.warn(\n            `check failed for cached value of ${key}\\nReason: ${event.reason}.\\nDeleting the cache key and trying to get a fresh value.`,\n            cached,\n          );\n          break;\n        case 'getCachedValueError':\n          logger.error(\n            `error with cache at ${key}. Deleting the cache key and trying to get a fresh value.`,\n            event.error,\n          );\n          break;\n        case 'getFreshValueError':\n          logger.error(\n            `getting a fresh value for ${key} failed`,\n            { fallbackToCache, forceFresh },\n            event.error,\n          );\n          break;\n        case 'getFreshValueStart':\n          getFreshValueStartTs = performance.now();\n          break;\n        case 'writeFreshValueSuccess': {\n          const totalTime = performance.now() - getFreshValueStartTs;\n          if (event.written) {\n            logger.log(\n              `Updated the cache value for ${key}.`,\n              `Getting a fresh value for this took ${formatDuration(\n                totalTime,\n              )}.`,\n              `Caching for ${formatCacheTime(\n                metadata,\n                formatDuration,\n              )} in ${cacheName}.`,\n            );\n          } else {\n            logger.log(\n              `Not updating the cache value for ${key}.`,\n              `Getting a fresh value for this took ${formatDuration(\n                totalTime,\n              )}.`,\n              `Thereby exceeding caching time of ${formatCacheTime(\n                metadata,\n                formatDuration,\n              )}`,\n            );\n          }\n          break;\n        }\n        case 'writeFreshValueError':\n          logger.error(`error setting cache: ${key}`, event.error);\n          break;\n        case 'getFreshValueSuccess':\n          freshValue = event.value;\n          break;\n        case 'checkFreshValueError':\n          logger.error(\n            `check failed for fresh value of ${key}\\nReason: ${event.reason}.`,\n            freshValue,\n          );\n          break;\n        case 'refreshValueStart':\n          refreshValueStartTS = performance.now();\n          break;\n        case 'refreshValueSuccess':\n          logger.log(\n            `Background refresh for ${key} successful.`,\n            `Getting a fresh value for this took ${formatDuration(\n              performance.now() - refreshValueStartTS,\n            )}.`,\n            `Caching for ${formatCacheTime(\n              metadata,\n              formatDuration,\n            )} in ${cacheName}.`,\n          );\n          break;\n        case 'refreshValueError':\n          logger.log(`Background refresh for ${key} failed.`, event.error);\n          break;\n      }\n    };\n  };\n}\n\nexport function mergeReporters<Value = unknown>(\n  ...reporters: (CreateReporter<Value> | null | undefined)[]\n): CreateReporter<Value> {\n  return (context) => {\n    const reporter = reporters.map((r) => r?.(context));\n    return (event) => {\n      reporter.forEach((r) => r?.(event));\n    };\n  };\n}\n", "import { Cache, CacheEntry, totalTtl } from './common';\n\nexport interface LRUishCache extends Omit<Cache, 'set'> {\n  set(\n    key: string,\n    value: CacheEntry<unknown>,\n    options?: { ttl?: number; start?: number },\n  ): void;\n}\n\nexport function lruCacheAdapter(lruCache: LRUishCache): Cache {\n  return {\n    name: lruCache.name || 'LRU',\n    set(key, value) {\n      const ttl = totalTtl(value?.metadata);\n      return lruCache.set(key, value, {\n        ttl: ttl === Infinity ? undefined : ttl,\n        start: value?.metadata?.createdTime,\n      });\n    },\n    get(key) {\n      return lruCache.get(key);\n    },\n    delete(key) {\n      return lruCache.delete(key);\n    },\n  };\n}\n\ninterface Redis3Multi {\n  set(key: string, value: string): Redis3Multi;\n  expireat(key: string, timestamp: number): Redis3Multi;\n  exec(cb: (err: Error | null, replies: (number | 'OK')[]) => void): unknown;\n}\nexport interface Redis3LikeCache {\n  name?: string;\n  set(\n    key: string,\n    value: string,\n    cb: (err: Error | null, reply: 'OK') => void,\n  ): unknown;\n  get(\n    key: string,\n    cb?: (err: Error | null, reply: string | null) => void,\n  ): unknown;\n  del(key: string, cb?: (err: Error | null, reply: number) => void): unknown;\n  multi(): Redis3Multi;\n}\n\nexport function redis3CacheAdapter(redisCache: Redis3LikeCache): Cache {\n  return {\n    name: redisCache.name || 'Redis3',\n    set(key, value) {\n      return new Promise<void>((res, rej) => {\n        const ttl = totalTtl(value?.metadata);\n        const createdTime = value?.metadata?.createdTime;\n        const cb = (err: unknown) => {\n          if (err) {\n            return rej(err);\n          }\n          res();\n        };\n\n        if (ttl > 0 && ttl < Infinity && typeof createdTime === 'number') {\n          redisCache\n            .multi()\n            .set(key, JSON.stringify(value))\n            .expireat(key, (ttl + createdTime) / 1000)\n            .exec(cb);\n        } else {\n          redisCache.set(key, JSON.stringify(value), cb);\n        }\n      });\n    },\n    get(key) {\n      return new Promise<CacheEntry | null | undefined>((res, rej) => {\n        redisCache.get(key, (err, reply) => {\n          if (err) {\n            rej(err);\n          } else if (reply == null) {\n            res(null);\n          } else {\n            try {\n              res(JSON.parse(reply));\n            } catch (err) {\n              rej(err);\n            }\n          }\n        });\n      });\n    },\n    delete(key) {\n      return new Promise<void>((res, rej) => {\n        redisCache.del(key, (err) => {\n          if (err) {\n            rej(err);\n          }\n          res();\n        });\n      });\n    },\n  };\n}\n\nexport interface RedisLikeCache {\n  name?: string;\n  set(\n    key: string,\n    value: string,\n    options?: { EXAT: number },\n  ): Promise<string | null>;\n  get(key: string): Promise<string | null>;\n  del(key: string): Promise<unknown>;\n}\n\nexport function redisCacheAdapter(redisCache: RedisLikeCache): Cache {\n  return {\n    name: redisCache.name || 'Redis',\n    set(key, value) {\n      const ttl = totalTtl(value?.metadata);\n      const createdTime = value?.metadata?.createdTime;\n\n      return redisCache.set(\n        key,\n        JSON.stringify(value),\n        ttl > 0 && ttl < Infinity && typeof createdTime === 'number'\n          ? {\n              EXAT: Math.ceil((ttl + createdTime) / 1000),\n            }\n          : undefined,\n      );\n    },\n    async get(key) {\n      const value = await redisCache.get(key);\n      if (value == null) {\n        return null;\n      }\n      return JSON.parse(value);\n    },\n    delete(key) {\n      return redisCache.del(key);\n    },\n  };\n}\n", "import type { GetFreshValue, GetFreshValueContext } from './common';\nimport { HANDLE } from './common';\n\ntype OnValueCallback<Value> = (\n  context: GetFreshValueContext & {\n    value: Value;\n  },\n) => void;\n\nexport type AddFn<Value, Param> = (\n  param: Param,\n  onValue?: OnValueCallback<Value>,\n) => GetFreshValue<Value>;\n\nexport function createBatch<Value, Param>(\n  getFreshValues: (params: Param[]) => Value[] | Promise<Value[]>,\n  autoSubmit: false,\n): {\n  submit: () => Promise<void>;\n  add: AddFn<Value, Param>;\n};\nexport function createBatch<Value, Param>(\n  getFreshValues: (params: Param[]) => Value[] | Promise<Value[]>,\n): {\n  add: AddFn<Value, Param>;\n};\nexport function createBatch<Value, Param>(\n  getFreshValues: (params: Param[]) => Value[] | Promise<Value[]>,\n  autoSubmit: boolean = true,\n): {\n  submit?: () => Promise<void>;\n  add: AddFn<Value, Param>;\n} {\n  const requests: [\n    param: Param,\n    res: (value: Value) => void,\n    rej: (reason: unknown) => void,\n  ][] = [];\n\n  let count = 0;\n  let submitted = false;\n  const submission = new Deferred<void>();\n\n  const checkSubmission = () => {\n    if (submitted) {\n      throw new Error('Can not add to batch after submission');\n    }\n  };\n\n  const submit = async () => {\n    if (count !== 0) {\n      autoSubmit = true;\n      return submission.promise;\n    }\n    checkSubmission();\n    submitted = true;\n\n    if (requests.length === 0) {\n      submission.resolve();\n      return;\n    }\n\n    try {\n      const results = await Promise.resolve(\n        getFreshValues(requests.map(([param]) => param)),\n      );\n      results.forEach((value, index) => requests[index][1](value));\n      submission.resolve();\n    } catch (err) {\n      requests.forEach(([_, __, rej]) => rej(err));\n      submission.resolve();\n    }\n  };\n\n  const trySubmitting = () => {\n    count--;\n    if (autoSubmit === false) {\n      return;\n    }\n    submit();\n  };\n\n  return {\n    ...(autoSubmit === false ? { submit } : {}),\n    add(param, onValue) {\n      checkSubmission();\n      count++;\n      let handled = false;\n\n      return Object.assign(\n        (context: GetFreshValueContext) => {\n          return new Promise<Value>((res, rej) => {\n            requests.push([\n              param,\n              (value) => {\n                onValue?.({ ...context, value });\n                res(value);\n              },\n              rej,\n            ]);\n            if (!handled) {\n              handled = true;\n              trySubmitting();\n            }\n          });\n        },\n        {\n          [HANDLE]: () => {\n            if (!handled) {\n              handled = true;\n              trySubmitting();\n            }\n          },\n        },\n      );\n    },\n  };\n}\n\nexport class Deferred<Value> {\n  readonly promise: Promise<Value>;\n  // @ts-ignore\n  readonly resolve: (value: Value | Promise<Value>) => void;\n  // @ts-ignore\n  readonly reject: (reason: unknown) => void;\n  constructor() {\n    this.promise = new Promise((res, rej) => {\n      // @ts-ignore\n      this.resolve = res;\n      // @ts-ignore\n      this.reject = rej;\n    });\n  }\n}\n", "import type { CacheMetadata } from './common';\n\nexport function logKey(key?: string) {\n  return key ? `for ${key} ` : '';\n}\n\nexport function assertCacheEntry(\n  entry: unknown,\n  key?: string,\n): asserts entry is {\n  metadata: CacheMetadata;\n  value: unknown;\n} {\n  if (!isRecord(entry)) {\n    throw new Error(\n      `Cache entry ${logKey(\n        key,\n      )}is not a cache entry object, it's a ${typeof entry}`,\n    );\n  }\n  if (\n    !isRecord(entry.metadata) ||\n    typeof entry.metadata.createdTime !== 'number' ||\n    (entry.metadata.ttl != null && typeof entry.metadata.ttl !== 'number') ||\n    (entry.metadata.swr != null && typeof entry.metadata.swr !== 'number')\n  ) {\n    throw new Error(\n      `Cache entry ${logKey(key)}does not have valid metadata property`,\n    );\n  }\n\n  if (!('value' in entry)) {\n    throw new Error(\n      `Cache entry for ${logKey(key)}does not have a value property`,\n    );\n  }\n}\n\nfunction isRecord(entry: unknown): entry is Record<string, unknown> {\n  return typeof entry === 'object' && entry !== null && !Array.isArray(entry);\n}\n", "import { CacheMetadata, staleWhileRevalidate } from './common';\n\nexport function shouldRefresh(\n  metadata: CacheMetadata,\n): 'now' | 'stale' | false {\n  if (metadata.ttl !== null) {\n    const valid = metadata.createdTime + (metadata.ttl || 0);\n    const stale = valid + (staleWhileRevalidate(metadata) || 0);\n    const now = Date.now();\n    if (now <= valid) {\n      return false;\n    }\n    if (now <= stale) {\n      return 'stale';\n    }\n\n    return 'now';\n  }\n  return false;\n}\n", "import type { Context } from './common';\nimport { MIGRATED } from './common';\n\nexport async function checkValue<Value>(\n  context: Context<Value>,\n  value: unknown,\n): Promise<\n  | { success: true; value: Value; migrated: boolean }\n  | { success: false; reason: unknown }\n> {\n  try {\n    const checkResponse = await context.checkValue(\n      value,\n      (value, updateCache = true) => ({\n        [MIGRATED]: updateCache,\n        value,\n      }),\n    );\n\n    if (typeof checkResponse === 'string') {\n      return { success: false, reason: checkResponse };\n    }\n\n    if (checkResponse == null || checkResponse === true) {\n      return {\n        success: true,\n        value: value as Value,\n        migrated: false,\n      };\n    }\n\n    if (checkResponse && typeof checkResponse[MIGRATED] === 'boolean') {\n      return {\n        success: true,\n        migrated: checkResponse[MIGRATED],\n        value: checkResponse.value,\n      };\n    }\n\n    return { success: false, reason: 'unknown' };\n  } catch (err) {\n    return {\n      success: false,\n      reason: err,\n    };\n  }\n}\n", "import { Context, CacheEntry } from './common';\nimport { assertCacheEntry } from './assertCacheEntry';\nimport { HANDLE } from './common';\nimport { shouldRefresh } from './shouldRefresh';\nimport { cachified } from './cachified';\nimport { Reporter } from './reporter';\nimport { checkValue } from './checkValue';\n\nexport const CACHE_EMPTY = Symbol();\nexport async function getCacheEntry<Value>(\n  { key, cache }: Pick<Context<Value>, 'key' | 'cache'>,\n  report: Reporter<Value>,\n): Promise<CacheEntry<unknown> | typeof CACHE_EMPTY> {\n  report({ name: 'getCachedValueStart' });\n  const cached = await cache.get(key);\n  report({ name: 'getCachedValueRead', entry: cached });\n  if (cached) {\n    assertCacheEntry(cached, key);\n    return cached;\n  }\n  return CACHE_EMPTY;\n}\n\nexport async function getCachedValue<Value>(\n  context: Context<Value>,\n  report: Reporter<Value>,\n  hasPendingValue: () => boolean,\n): Promise<Value | typeof CACHE_EMPTY> {\n  const {\n    key,\n    cache,\n    staleWhileRevalidate,\n    staleRefreshTimeout,\n    metadata,\n    getFreshValue: { [HANDLE]: handle },\n  } = context;\n  try {\n    const cached = await getCacheEntry(context, report);\n\n    if (cached === CACHE_EMPTY) {\n      report({ name: 'getCachedValueEmpty' });\n      return CACHE_EMPTY;\n    }\n\n    const refresh = shouldRefresh(cached.metadata);\n    const staleRefresh =\n      refresh === 'stale' ||\n      (refresh === 'now' && staleWhileRevalidate === Infinity);\n\n    if (refresh === 'now') {\n      report({ name: 'getCachedValueOutdated', ...cached });\n    }\n\n    if (staleRefresh) {\n      // refresh cache in background so future requests are faster\n      setTimeout(() => {\n        report({ name: 'refreshValueStart' });\n        void cachified({\n          ...context,\n          reporter: () => () => {},\n          getFreshValue({ metadata }) {\n            return context.getFreshValue({ metadata, background: true });\n          },\n          forceFresh: true,\n          fallbackToCache: false,\n        })\n          .then((value) => {\n            report({ name: 'refreshValueSuccess', value });\n          })\n          .catch((error) => {\n            report({ name: 'refreshValueError', error });\n          });\n      }, staleRefreshTimeout);\n    }\n\n    if (!refresh || staleRefresh) {\n      const valueCheck = await checkValue(context, cached.value);\n      if (valueCheck.success) {\n        report({\n          name: 'getCachedValueSuccess',\n          value: valueCheck.value,\n          migrated: valueCheck.migrated,\n        });\n        if (!staleRefresh) {\n          // Notify batch that we handled this call using cached value\n          handle?.();\n        }\n\n        if (valueCheck.migrated) {\n          setTimeout(async () => {\n            try {\n              const cached = await context.cache.get(context.key);\n\n              // Unless cached value was changed in the meantime or is about to\n              // change\n              if (\n                cached &&\n                cached.metadata.createdTime === metadata.createdTime &&\n                !hasPendingValue()\n              ) {\n                // update with migrated value\n                await context.cache.set(context.key, {\n                  ...cached,\n                  value: valueCheck.value,\n                });\n              }\n            } catch (err) {\n              /* \u00AF\\_(\u30C4)_/\u00AF */\n            }\n          }, 0);\n        }\n\n        return valueCheck.value;\n      } else {\n        report({ name: 'checkCachedValueErrorObj', reason: valueCheck.reason });\n        report({\n          name: 'checkCachedValueError',\n          reason:\n            valueCheck.reason instanceof Error\n              ? valueCheck.reason.message\n              : String(valueCheck.reason),\n        });\n\n        await cache.delete(key);\n      }\n    }\n  } catch (error: unknown) {\n    report({ name: 'getCachedValueError', error });\n\n    await cache.delete(key);\n  }\n\n  return CACHE_EMPTY;\n}\n", "import { Context, CacheMetadata, createCacheEntry } from './common';\nimport { getCacheEntry, CACHE_EMPTY } from './getCachedValue';\nimport { shouldRefresh } from './shouldRefresh';\nimport { Reporter } from './reporter';\nimport { checkValue } from './checkValue';\n\nexport async function getFreshValue<Value>(\n  context: Context<Value>,\n  metadata: CacheMetadata,\n  report: Reporter<Value>,\n): Promise<Value> {\n  const { fallbackToCache, key, getFreshValue, forceFresh, cache } = context;\n\n  let value: unknown;\n  try {\n    report({ name: 'getFreshValueStart' });\n    const freshValue = await getFreshValue({\n      metadata: context.metadata,\n      background: false,\n    });\n    value = freshValue;\n    report({ name: 'getFreshValueSuccess', value: freshValue });\n  } catch (error) {\n    report({ name: 'getFreshValueError', error });\n\n    // in case a fresh value was forced (and errored) we might be able to\n    // still get one from cache\n    if (forceFresh && fallbackToCache > 0) {\n      const entry = await getCacheEntry(context, report);\n      if (\n        entry === CACHE_EMPTY ||\n        entry.metadata.createdTime + fallbackToCache < Date.now()\n      ) {\n        throw error;\n      }\n      value = entry.value;\n      report({ name: 'getFreshValueCacheFallback', value });\n    } else {\n      // we are either not allowed to check the cache or already checked it\n      // nothing we can do anymore\n      throw error;\n    }\n  }\n\n  const valueCheck = await checkValue(context, value);\n  if (!valueCheck.success) {\n    report({ name: 'checkFreshValueErrorObj', reason: valueCheck.reason });\n    report({\n      name: 'checkFreshValueError',\n      reason:\n        valueCheck.reason instanceof Error\n          ? valueCheck.reason.message\n          : String(valueCheck.reason),\n    });\n\n    throw new Error(`check failed for fresh value of ${key}`, {\n      cause: valueCheck.reason,\n    });\n  }\n\n  try {\n    const write = shouldRefresh(metadata) !== 'now';\n    if (write) {\n      await cache.set(key, createCacheEntry(value, metadata));\n    }\n    report({\n      name: 'writeFreshValueSuccess',\n      metadata,\n      migrated: valueCheck.migrated,\n      written: write,\n    });\n  } catch (error: unknown) {\n    report({ name: 'writeFreshValueError', error });\n  }\n\n  return valueCheck.value;\n}\n", "import {\n  CachifiedOptions,\n  CachifiedOptionsWithSchema,\n  Cache,\n  CacheEntry,\n  createContext,\n} from './common';\nimport { CACHE_EMPTY, getCachedValue } from './getCachedValue';\nimport { getFreshValue } from './getFreshValue';\nimport { shouldRefresh } from './shouldRefresh';\n\n// This is to prevent requesting multiple fresh values in parallel\n// while revalidating or getting first value\n// Keys are unique per cache but may be used by multiple caches\nconst pendingValuesByCache = new WeakMap<Cache, Map<string, any>>();\n\nexport async function cachified<Value, InternalValue>(\n  options: CachifiedOptionsWithSchema<Value, InternalValue>,\n): Promise<Value>;\nexport async function cachified<Value>(\n  options: CachifiedOptions<Value>,\n): Promise<Value>;\nexport async function cachified<Value>(\n  options: CachifiedOptions<Value>,\n): Promise<Value> {\n  const context = createContext(options);\n  const { key, cache, forceFresh, report, metadata } = context;\n\n  // Register this cache\n  if (!pendingValuesByCache.has(cache)) {\n    pendingValuesByCache.set(cache, new Map());\n  }\n  const pendingValues: Map<\n    string,\n    CacheEntry<Promise<Value>> & { resolve: (value: Value) => void }\n  > = pendingValuesByCache.get(cache)!;\n\n  const hasPendingValue = () => {\n    return pendingValues.has(key);\n  };\n  const cachedValue = !forceFresh\n    ? await getCachedValue(context, report, hasPendingValue)\n    : CACHE_EMPTY;\n  if (cachedValue !== CACHE_EMPTY) {\n    report({ name: 'done', value: cachedValue });\n    return cachedValue;\n  }\n\n  if (pendingValues.has(key)) {\n    const { value: pendingRefreshValue, metadata } = pendingValues.get(key)!;\n    if (!shouldRefresh(metadata)) {\n      report({ name: 'getFreshValueHookPending' });\n      const value = await pendingRefreshValue;\n      report({ name: 'done', value });\n      return value;\n    }\n  }\n\n  let resolveFromFuture: (value: Value) => void;\n  const freshValue = Promise.race([\n    // try to get a fresh value\n    getFreshValue(context, metadata, report),\n    // or when a future call is faster, we'll take it's value\n    // this happens when getting value of first call takes longer then ttl + second response\n    new Promise<Value>((r) => {\n      resolveFromFuture = r;\n    }),\n  ]).finally(() => {\n    pendingValues.delete(key);\n  });\n\n  // here we inform past calls that we got a response\n  if (pendingValues.has(key)) {\n    const { resolve } = pendingValues.get(key)!;\n    freshValue.then((value) => resolve(value));\n  }\n\n  pendingValues.set(key, {\n    metadata,\n    value: freshValue,\n    // here we receive a fresh value from a future call\n    resolve: resolveFromFuture!,\n  });\n\n  const value = await freshValue;\n  report({ name: 'done', value });\n  return value;\n}\n", "import { Cache, createCacheEntry, staleWhileRevalidate } from './common';\nimport { CACHE_EMPTY, getCacheEntry } from './getCachedValue';\nimport { shouldRefresh } from './shouldRefresh';\n\ninterface SoftPurgeOpts {\n  cache: Cache;\n  key: string;\n  /**\n   * Force the entry to outdate after ms\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Force the entry to outdate after ms\n   */\n  swr?: number;\n}\n\nexport async function softPurge({\n  cache,\n  key,\n  ...swrOverwrites\n}: SoftPurgeOpts) {\n  const swrOverwrite = swrOverwrites.swr ?? swrOverwrites.staleWhileRevalidate;\n  const entry = await getCacheEntry({ cache, key }, () => {});\n\n  if (entry === CACHE_EMPTY || shouldRefresh(entry.metadata)) {\n    return;\n  }\n\n  const ttl = entry.metadata.ttl || Infinity;\n  const swr = staleWhileRevalidate(entry.metadata) || 0;\n  const lt = Date.now() - entry.metadata.createdTime;\n\n  await cache.set(\n    key,\n    createCacheEntry(entry.value, {\n      ttl: 0,\n      swr: swrOverwrite === undefined ? ttl + swr : swrOverwrite + lt,\n      createdTime: entry.metadata.createdTime,\n    }),\n  );\n}\n"],
  "mappings": "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",
  "names": ["checkValue", "_a", "_b", "staleWhileRevalidate", "err", "_a", "value", "staleWhileRevalidate", "metadata", "cached", "getFreshValue", "metadata", "value", "_a"]
}
