import { Session, SessionStorage } from "@remix-run/server-runtime";
import { AuthenticateOptions, Strategy } from "./strategy";
export interface AuthenticateCallback<User> {
    (user: User): Promise<Response>;
}
/**
 * Extra options for the authenticator.
 */
export interface AuthenticatorOptions {
    sessionKey?: AuthenticateOptions["sessionKey"];
    sessionErrorKey?: AuthenticateOptions["sessionErrorKey"];
    sessionStrategyKey?: AuthenticateOptions["sessionStrategyKey"];
    throwOnError?: AuthenticateOptions["throwOnError"];
}
export declare class Authenticator<User = unknown> {
    private sessionStorage;
    /**
     * A map of the configured strategies, the key is the name of the strategy
     * @private
     */
    private strategies;
    readonly sessionKey: NonNullable<AuthenticatorOptions["sessionKey"]>;
    readonly sessionErrorKey: NonNullable<AuthenticatorOptions["sessionErrorKey"]>;
    readonly sessionStrategyKey: NonNullable<AuthenticateOptions["sessionStrategyKey"]>;
    private readonly throwOnError;
    /**
     * Create a new instance of the Authenticator.
     *
     * It receives a instance of the SessionStorage. This session storage could
     * be created using any method exported by Remix, this includes:
     * - `createSessionStorage`
     * - `createFileSystemSessionStorage`
     * - `createCookieSessionStorage`
     * - `createMemorySessionStorage`
     *
     * It optionally receives an object with extra options. The supported options
     * are:
     * - `sessionKey`: The key used to store and read the user in the session storage.
     * @example
     * import { sessionStorage } from "./session.server";
     * let authenticator = new Authenticator(sessionStorage);
     * @example
     * import { sessionStorage } from "./session.server";
     * let authenticator = new Authenticator(sessionStorage, {
     *   sessionKey: "token",
     * });
     */
    constructor(sessionStorage: SessionStorage, options?: AuthenticatorOptions);
    /**
     * Call this method with the Strategy, the optional name allows you to setup
     * the same strategy multiple times with different names.
     * It returns the Authenticator instance for concatenation.
     * @example
     * authenticator
     *  .use(new SomeStrategy({}, (user) => Promise.resolve(user)))
     *  .use(new SomeStrategy({}, (user) => Promise.resolve(user)), "another");
     */
    use(strategy: Strategy<User, never>, name?: string): Authenticator;
    /**
     * Call this method with the name of the strategy you want to remove.
     * It returns the Authenticator instance for concatenation.
     * @example
     * authenticator.unuse("another").unuse("some");
     */
    unuse(name: string): Authenticator;
    /**
     * Call this to authenticate a request using some strategy. You pass the name
     * of the strategy you want to use and the request to authenticate.
     * @example
     * async function action({ request }: ActionArgs) {
     *   let user = await authenticator.authenticate("some", request);
     * };
     * @example
     * async function action({ request }: ActionArgs) {
     *   return authenticator.authenticate("some", request, {
     *     successRedirect: "/private",
     *     failureRedirect: "/login",
     *   });
     * };
     */
    authenticate(strategy: string, request: Request, options: Pick<AuthenticateOptions, "failureRedirect" | "throwOnError" | "context"> & {
        successRedirect: AuthenticateOptions["successRedirect"];
    }): Promise<never>;
    authenticate(strategy: string, request: Request, options: Pick<AuthenticateOptions, "successRedirect" | "throwOnError" | "context"> & {
        failureRedirect: AuthenticateOptions["failureRedirect"];
    }): Promise<User>;
    authenticate(strategy: string, request: Request, options?: Pick<AuthenticateOptions, "successRedirect" | "failureRedirect" | "throwOnError" | "context">): Promise<User>;
    /**
     * Call this to check if the user is authenticated. It will return a Promise
     * with the user object or null, you can use this to check if the user is
     * logged-in or not without triggering the whole authentication flow.
     * @example
     * async function loader({ request }: LoaderArgs) {
     *   // if the user is not authenticated, redirect to login
     *   let user = await authenticator.isAuthenticated(request, {
     *     failureRedirect: "/login",
     *   });
     *   // do something with the user
     *   return json(privateData);
     * }
     * @example
     * async function loader({ request }: LoaderArgs) {
     *   // if the user is authenticated, redirect to /dashboard
     *   await authenticator.isAuthenticated(request, {
     *     successRedirect: "/dashboard"
     *   });
     *   return json(publicData);
     * }
     * @example
     * async function loader({ request }: LoaderArgs) {
     *   // manually handle what happens if the user is or not authenticated
     *   let user = await authenticator.isAuthenticated(request);
     *   if (!user) return json(publicData);
     *   return sessionLoader(request);
     * }
     */
    isAuthenticated(request: Request | Session, options?: {
        successRedirect?: never;
        failureRedirect?: never;
        headers?: never;
    }): Promise<User | null>;
    isAuthenticated(request: Request | Session, options: {
        successRedirect: string;
        failureRedirect?: never;
        headers?: HeadersInit;
    }): Promise<null>;
    isAuthenticated(request: Request | Session, options: {
        successRedirect?: never;
        failureRedirect: string;
        headers?: HeadersInit;
    }): Promise<User>;
    isAuthenticated(request: Request | Session, options: {
        successRedirect: string;
        failureRedirect: string;
        headers?: HeadersInit;
    }): Promise<null>;
    /**
     * Destroy the user session throw a redirect to another URL.
     * @example
     * async function action({ request }: ActionArgs) {
     *   await authenticator.logout(request, { redirectTo: "/login" });
     * }
     */
    logout(request: Request | Session, options: {
        redirectTo: string;
    }): Promise<never>;
}
