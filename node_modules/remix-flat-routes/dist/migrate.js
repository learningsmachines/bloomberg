"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToRoute = exports.migrate = void 0;
const v1_route_convention_1 = require("@remix-run/v1-route-convention");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const routes_1 = require("./routes");
const pathSepRegex = new RegExp(`\\${path.sep}`, 'g');
const routeExtensions = ['.js', '.jsx', '.ts', '.tsx', '.md', '.mdx'];
function migrate(sourceDir, targetDir, options = { convention: 'flat-files', force: false }) {
    if (sourceDir.startsWith('./')) {
        sourceDir = sourceDir.substring(2);
    }
    if (targetDir.startsWith('./')) {
        targetDir = targetDir.substring(2);
    }
    console.log(`🛠️ Migrating to flat-routes using ${options.convention} convention...`);
    console.log(`🗂️ source: ${sourceDir}`);
    console.log(`🗂️ target: ${targetDir}`);
    console.log();
    const routes = (0, v1_route_convention_1.createRoutesFromFolders)(routes_1.defineRoutes, {
        appDirectory: './',
        routesDirectory: sourceDir,
    });
    console.log(routes);
    Object.entries(routes).forEach(([id, route]) => {
        let { path: routePath, file, parentId } = route;
        let extension = path.extname(file);
        let flat = convertToRoute(routes, sourceDir, id, parentId, routePath, !!route.index, options.convention);
        // replace sourceDir with targetDir
        flat = path.join(targetDir, flat);
        //console.log(`📝 ${id}`)
        if (options.convention === 'flat-folders') {
            if (!routeExtensions.includes(extension)) {
                return;
            }
            fs.mkdirSync(flat, { recursive: true });
            fs.cpSync(file, path.join(flat, `/route${extension}`), {
                force: true,
            });
        }
        else if (options.convention === 'hybrid') {
            if (!routeExtensions.includes(extension)) {
                return;
            }
            fs.mkdirSync(path.dirname(flat), { recursive: true });
            const targetFile = `${flat}${extension}`;
            fs.cpSync(file, targetFile, { force: true });
        }
        else if (options.convention === 'flat-files') {
            const targetFile = `${flat}${extension}`;
            fs.cpSync(file, targetFile, { force: true });
        }
    });
    console.log('🏁 Finished!');
}
exports.migrate = migrate;
function convertToRoute(routes, sourceDir, id, parentId, routePath, index, convention) {
    // strip sourceDir from id and parentId
    let routeId = id.substring(sourceDir.length + 1);
    parentId =
        parentId === 'root' ? parentId : parentId.substring(sourceDir.length + 1);
    if (parentId && parentId !== 'root') {
        if (convention !== 'hybrid' && (routePath === null || routePath === void 0 ? void 0 : routePath.includes('/'))) {
            // multi-segment route, so need to fixup parent for flat-routes (trailing _)
            // strip parent route from route
            let currentPath = routeId.substring(parentId.length + 1);
            let routeSegments = getRouteSegments(currentPath);
            let dottedSegments = getEscapedDottedRouteSegments(routeSegments[0]);
            console.log({ routeSegments, dottedSegments });
            if (dottedSegments.length > 1) {
                const [first, ...rest] = dottedSegments;
                //rewrite id to use trailing _ for parent
                routeId = `${parentId}/${first}_.${rest.join('.')}`;
                if (routeSegments.length > 1) {
                    routeSegments.shift();
                    routeId += `/${routeSegments.join('.')}`;
                }
            }
            else {
                routeId = `${parentId}/${routeSegments.join('.')}`;
            }
        }
    }
    if (convention === 'hybrid') {
        let flat = routeId
            // convert path separators /+ hybrid format
            .replace(pathSepRegex, '+/')
            // convert single _ to [_] due to conflict with new pathless layout prefix
            .replace(/(^|\/|\.)_([^_.])/g, '$1[_]$2')
            // convert double __ to single _ for pathless layout prefix
            .replace(/(^|\/|\.)__/g, '$1_')
            // convert index to _index for index routes
            .replace(/(^|\/|\.)index$/, '$1_index');
        // check if route is a parent route
        // is so, move to hybrid folder (+) as _layout route
        if (Object.values(routes).some(r => r.parentId === id)) {
            flat = flat + '+/_layout';
        }
        return flat;
    }
    // convert to flat route convention
    let flat = routeId
        // convert path separators to dots
        .replace(pathSepRegex, '.')
        // convert single _ to [_] due to conflict with new pathless layout prefix
        .replace(/(^|\/|\.)_([^_.])/g, '$1[_]$2')
        // convert double __ to single _ for pathless layout prefix
        .replace(/(^|\/|\.)__/g, '$1_')
        // convert index to _index for index routes
        .replace(/(^|\/|\.)index$/, '$1_index');
    return flat;
}
exports.convertToRoute = convertToRoute;
function getRouteSegments(routePath) {
    return routePath.split('/');
}
function getEscapedDottedRouteSegments(name) {
    let routeSegments = [];
    let i = 0;
    let routeSegment = '';
    let state = 'START';
    let subState = 'NORMAL';
    let pushRouteSegment = (routeSegment) => {
        if (routeSegment) {
            routeSegments.push(routeSegment);
        }
    };
    while (i < name.length) {
        let char = name[i];
        switch (state) {
            case 'START':
                // process existing segment
                pushRouteSegment(routeSegment);
                routeSegment = '';
                state = 'PATH';
                continue; // restart without advancing index
            case 'PATH':
                if (char === '.' && subState === 'NORMAL') {
                    state = 'START';
                    break;
                }
                else if (char === '[') {
                    subState = 'ESCAPE';
                    break;
                }
                else if (char === ']') {
                    subState = 'NORMAL';
                    break;
                }
                routeSegment += char;
                break;
        }
        i++; // advance to next character
    }
    // process remaining segment
    pushRouteSegment(routeSegment);
    return routeSegments;
}
