#!/usr/bin/env node

// src/commands/add.ts
import { existsSync as existsSync2, promises as fs3 } from "fs";
import path3 from "path";

// src/get-config.ts
import { promises as fs } from "fs";
import { cosmiconfig } from "cosmiconfig";
import * as z from "zod";
import ora from "ora";

// src/logger.ts
import chalk from "chalk";
var logger = {
  error(...args) {
    console.error(chalk.red(...args));
  },
  warn(...args) {
    console.warn(chalk.yellow(...args));
  },
  info(...args) {
    console.info(chalk.cyan(...args));
  },
  success(...args) {
    console.info(chalk.green(...args));
  }
};

// src/get-config.ts
var explorer;
function getExplorer() {
  if (!explorer) {
    const paths = ["sly.json", "sly/sly.json"];
    const directories = ["", ".config", "config", "other"];
    explorer = cosmiconfig("sly", {
      searchPlaces: directories.flatMap(
        (dir) => paths.map((path4) => `${dir}/${path4}`)
      ),
      cache: Boolean(process.env.CACHE)
    });
  }
  return explorer;
}
var libraryConfigSchema = z.object({
  name: z.string(),
  directory: z.string(),
  postinstall: z.union([z.string().optional(), z.array(z.string())]),
  transformers: z.array(z.string())
}).strict();
var configSchema = z.object({
  $schema: z.string().optional(),
  libraries: z.array(libraryConfigSchema)
}).strict();
async function getConfigFilepath() {
  const configResult = await getExplorer().search();
  if (!configResult) {
    logger.error(`Couldn't find sly.json.`);
    process.exit(1);
  }
  return configResult.filepath;
}
async function getConfig() {
  const configResult = await getExplorer().search();
  if (!configResult) {
    return null;
  }
  try {
    return configSchema.parse(configResult.config);
  } catch (error) {
    throw new Error(`Invalid configuration found in /sly.json.`);
  }
}
async function setConfig(fn) {
  const spinner = ora(`Saving sly.json settings\u2026`).start();
  const config = await getConfig() ?? {
    $schema: `${process.env.REGISTRY_URL || "https://sly-cli.fly.dev"}/registry/config.json`,
    libraries: []
  };
  const newConfig = configSchema.parse(fn(config));
  const configFile = await getExplorer().search();
  await fs.writeFile(
    configFile ? configFile.filepath : "sly.json",
    JSON.stringify(newConfig, null, 2),
    "utf8"
  );
  if (process.env.CACHE) {
    getExplorer().clearSearchCache();
  }
  spinner.succeed();
}

// ../site/app/schemas.ts
import { z as z2 } from "zod";
var metaSchema = z2.object({
  name: z2.string(),
  source: z2.string(),
  description: z2.string().optional(),
  license: z2.string()
});
var registryIndexSchema = z2.object({
  version: z2.string(),
  libraries: z2.array(metaSchema)
});
var libraryItemSchema = z2.object({
  name: z2.string(),
  dependencies: z2.array(z2.string()).optional().default([]),
  devDependencies: z2.array(z2.string()).optional().default([]),
  registryDependencies: z2.array(z2.string()).optional().default([])
});
var libraryIndexSchema = z2.object({
  version: z2.string(),
  meta: metaSchema,
  resources: z2.array(libraryItemSchema)
});
var libraryItemWithContentSchema = libraryItemSchema.extend({
  files: z2.array(
    z2.object({
      name: z2.string(),
      content: z2.string()
    })
  ),
  meta: metaSchema
});
var githubFile = z2.object({
  type: z2.literal("file"),
  name: z2.string(),
  path: z2.string(),
  sha: z2.string(),
  size: z2.number(),
  url: z2.string(),
  html_url: z2.string(),
  git_url: z2.string(),
  download_url: z2.string()
});

// src/registry.ts
import * as z3 from "zod";
import { cachified } from "cachified";

// src/cache.ts
import fs2 from "fs";
import path from "path";
import { LRUCache } from "lru-cache";
import { lruCacheAdapter } from "cachified";
var lru = new LRUCache({ max: 1e3 });
var cache = lruCacheAdapter(lru);
var CACHE_DIRECTORY = process.env.CACHE_DIRECTORY || "node_modules/.cache/@sly-cli";
var CACHE_FILENAME = path.join(CACHE_DIRECTORY, "sly.json");
function dumpCache() {
  if (!fs2.existsSync(CACHE_DIRECTORY)) {
    fs2.mkdirSync(CACHE_DIRECTORY, { recursive: true });
  }
  fs2.writeFileSync(CACHE_FILENAME, JSON.stringify(lru.dump()));
}
function restoreCache() {
  if (fs2.existsSync(CACHE_FILENAME)) {
    const existingCache = fs2.readFileSync(CACHE_FILENAME);
    lru.load(JSON.parse(existingCache.toString()));
  }
}
function clearCache() {
  lru.load([]);
  dumpCache();
}

// src/registry.ts
var baseUrl = process.env.REGISTRY_URL || "https://sly-cli.fly.dev";
async function getRegistryIndex() {
  try {
    const [result] = await fetchRegistry([`index.json`]);
    return registryIndexSchema.parse(result);
  } catch (error) {
    throw new Error(`Failed to fetch the registry index`);
  }
}
async function getLibraryIndex(library) {
  try {
    const [result] = await fetchRegistry([`${library}.json`]);
    return libraryIndexSchema.parse(result);
  } catch (error) {
    throw new Error(`Failed to fetch ${library} index from registry.`);
  }
}
async function fetchTree(library, tree) {
  const result = await fetchRegistry(
    tree.map((item) => `${library}/${item.name}.json`)
  ).catch((error) => {
    logger.error(error);
    throw new Error(`Failed to fetch tree from registry.`);
  });
  return z3.array(libraryItemWithContentSchema).parseAsync(result).catch((error) => {
    logger.error(error);
    throw new Error(`Failed to parse tree from registry.`);
  });
}
async function fetchRegistry(paths) {
  try {
    const response = await Promise.all(
      paths.map(
        (path4) => cachified({
          // TODO: add package.json version to key
          key: `${baseUrl}/registry/${path4}`,
          cache,
          async getFreshValue() {
            return fetch(`${baseUrl}/registry/${path4}`).then(
              (response2) => response2.json()
            );
          }
        })
      )
    );
    if (process.env.CACHE) {
      void dumpCache();
    }
    return response;
  } catch (error) {
    logger.error(error);
    throw new Error(`Failed to fetch registry from ${baseUrl}.`);
  }
}

// src/commands/add.ts
import chalk4 from "chalk";
import { Command as Command2 } from "commander";
import { execa } from "execa";
import ora2 from "ora";
import prompts3 from "prompts";
import * as z5 from "zod";

// src/transformers.ts
import path2 from "path";
import { existsSync } from "fs";
import chalk2 from "chalk";
async function resolveTransformers(transformers) {
  const modules = await Promise.all(
    transformers.map(async (transformer) => {
      const configPath = await getConfigFilepath();
      const transformerPath = path2.resolve(configPath, "..", transformer);
      if (!existsSync(transformerPath)) {
        logger.error(
          `Transformer ${transformer} does not exist relative to ${configPath}`
        );
        process.exit(1);
      }
      return import(transformerPath).catch((error) => {
        logger.error(`Failed to load transformer ${transformer}.`);
        if (error.code === "ERR_UNKNOWN_FILE_EXTENSION") {
          logger.warn(
            `Sly must be installed to your node_modules to use typescript transformers.`
          );
          logger.warn(chalk2.bold(`npm install --save-dev @sly-cli/sly`));
        } else {
          logger.error(error);
        }
        process.exit(1);
      });
    })
  );
  return modules;
}

// src/commands/library.ts
import { Command } from "commander";
import chalk3 from "chalk";
import prompts2 from "prompts";

// src/prompts.ts
import prompts from "prompts";
async function confirmOrQuit(message) {
  const proceed = await confirm(message);
  if (!proceed) {
    process.exit(0);
  }
}
async function confirm(message) {
  if (process.env.YES)
    return true;
  const { proceed } = await prompts({
    type: "confirm",
    name: "proceed",
    message,
    initial: true
  });
  return Boolean(proceed);
}

// src/commands/library.ts
import { z as z4 } from "zod";
var libraryCommand = new Command().name("library").alias("lib").alias("l").argument("[name]", "the name of the library to add").description(`Configure and add libraries to your project`).action(async (argName) => {
  if (argName) {
    const { libraries } = await getRegistryIndex();
    const library = libraries.find((lib) => lib.name === argName);
    if (!library) {
      logger.error(`Library ${argName} not found`);
      process.exit(1);
    }
    return initLibrary(library.name);
  }
  const config = await getConfig();
  const CONFIG_LIBS = "\n    Configure libraries ->";
  const choice = config ? await chooseLibrary([
    ...config.libraries,
    {
      name: CONFIG_LIBS
    }
  ]) : CONFIG_LIBS;
  if (choice === CONFIG_LIBS) {
    return configureLibraries();
  }
  return initLibrary(choice);
});
async function configureLibraries() {
  const existingConfig = await getConfig();
  const { libraries } = await getRegistryIndex();
  const answers = await z4.object({
    libraries: z4.array(z4.string())
  }).parseAsync(
    await prompts2([
      {
        type: "multiselect",
        name: "libraries",
        message: `Which libraries would you like to use?`,
        choices: libraries.map((library) => ({
          title: library.name,
          description: library.description,
          value: library.name,
          selected: existingConfig?.libraries.some(
            ({ name }) => library.name === name
          ) ?? false
        })),
        min: 1
      }
    ])
  ).catch(() => process.exit(1));
  const newLibraries = answers.libraries.filter(
    (name) => !existingConfig?.libraries.some((library) => library.name === name)
  );
  for (const name of newLibraries) {
    await initLibrary(name);
  }
  const removedLibraries = existingConfig?.libraries.filter(
    (library) => !answers.libraries.includes(library.name)
  );
  if (removedLibraries?.length) {
    await confirmOrQuit(
      `Are you sure you want to remove ${removedLibraries.map((library) => chalk3.cyan(library.name)).join(", ")}?`
    );
    await setConfig((config) => {
      return {
        ...config,
        libraries: config.libraries.filter(
          ({ name }) => !removedLibraries.some((library) => library.name === name)
        )
      };
    });
  }
}
async function chooseLibrary(libraries) {
  const { library } = await z4.object({
    library: z4.string()
  }).parseAsync(
    await prompts2({
      type: "select",
      name: "library",
      message: `Which library would you like to use?`,
      choices: libraries.map((library2) => ({
        title: library2.name,
        value: library2.name
      }))
    })
  ).catch(() => process.exit(1));
  return library;
}
async function initLibrary(name) {
  const config = await getConfig();
  const existingConfig = config?.libraries.find(
    (library) => library.name === name
  ) ?? {
    name,
    directory: "./components",
    postinstall: [],
    transformers: []
  };
  const answers = await z4.object({
    directory: z4.string(),
    postinstall: z4.string().transform((value) => value.trim() ? value.trim().split(" ") : [])
  }).parseAsync(
    await prompts2([
      {
        type: "text",
        name: "directory",
        message: `Pick a directory for ${chalk3.cyan(name)}`,
        initial: existingConfig.directory
      },
      {
        type: "text",
        name: "postinstall",
        message: `Run a command after installing ${chalk3.cyan(name)}?`,
        initial: Array.isArray(existingConfig.postinstall) ? existingConfig.postinstall.join(" ") : existingConfig.postinstall
      }
    ])
  ).catch(() => process.exit(1));
  const newSettings = libraryConfigSchema.parse({
    name,
    directory: answers.directory,
    postinstall: answers.postinstall,
    transformers: existingConfig.transformers
  });
  await confirmOrQuit(`Save settings to ${chalk3.cyan("sly.json")}?`);
  await setConfig((config2) => {
    const existingLibraryConfig = config2.libraries.find(
      (library) => library.name === name
    );
    if (existingLibraryConfig) {
      existingLibraryConfig.directory = newSettings.directory;
      existingLibraryConfig.postinstall = newSettings.postinstall;
    } else {
      config2.libraries.push(newSettings);
    }
    return config2;
  });
}

// src/commands/add.ts
function hasLibrary(config, name) {
  return config?.libraries.find((lib) => lib.name === name);
}
var add = new Command2().name("add").description("add code to your project").argument("[library]", "the library to add from").argument("[files...]", "the files to add").option(
  "-d, --directory [dir], --dir [dir]",
  "set output directory (override sly.json)"
).option("-o, --overwrite", "overwrite existing files.", false).hook("preAction", () => {
  const options = add.optsWithGlobals();
  process.env.OVERWRITE = options.overwrite ? "true" : "";
  process.env.DIRECTORY = options.directory ?? "";
}).action(async (libArg, filesArg) => {
  let library = z5.string().optional().parse(libArg);
  const items = z5.array(z5.string()).default([]).parse(filesArg);
  let config = await getConfig();
  if (!library) {
    if (!config) {
      await configureLibraries();
      config = await getConfig();
      if (!config) {
        logger.error(`Something went wrong. Please try again.`);
        process.exit(1);
      }
    }
    const CONFIG_LIBS = "\n    Configure libraries ->";
    library = config ? await chooseLibrary([
      ...config.libraries,
      {
        name: CONFIG_LIBS
      }
    ]) : CONFIG_LIBS;
    if (library === CONFIG_LIBS) {
      return configureLibraries();
    }
  } else {
    if (!process.env.DIRECTORY && (!config || !hasLibrary(config, library))) {
      const { libraries } = await getRegistryIndex();
      if (!libraries.find((lib) => lib.name === library)) {
        logger.error(`Library ${library} not in registry`);
        process.exit(1);
      }
      await initLibrary(library);
      config = await getConfig();
    }
  }
  if (!process.env.DIRECTORY && !config) {
    logger.error(`Something went wrong. Please try again.`);
    process.exit(1);
  }
  const registryIndex = await getLibraryIndex(library);
  let selectedComponents = items;
  if (!items?.length) {
    const { items: items2 } = await z5.object({
      items: z5.array(z5.string()).min(1)
    }).parseAsync(
      await prompts3({
        type: "autocompleteMultiselect",
        name: "items",
        message: "Which items would you like to add?",
        hint: "Space to select. A to toggle all. Enter to submit.",
        instructions: false,
        choices: registryIndex.resources.map((entry) => ({
          title: entry.name,
          value: entry.name
        })),
        min: 1
      })
    ).catch(() => process.exit(1));
    selectedComponents = items2;
  }
  const treeSet = new Set(
    registryIndex.resources.filter(
      (item) => selectedComponents?.includes(item.name)
    )
  );
  for (const item of treeSet) {
    if (item.registryDependencies.length > 0) {
      const deps = item.registryDependencies.map(
        (dep) => registryIndex.resources.find((item2) => item2.name === dep)
      );
      for (const dep of deps) {
        if (dep) {
          treeSet.add(dep);
        } else {
          logger.error(`Dependency ${dep} not found in registry`);
        }
      }
    }
  }
  const treeSetItemsThatAreNotSelected = Array.from(treeSet).filter(
    (item) => !selectedComponents.includes(item.name)
  );
  if (treeSetItemsThatAreNotSelected.length > 0) {
    logger.info(`The selected items depend on these other items:`);
    for (const item of treeSetItemsThatAreNotSelected) {
      logger.info(`- ${chalk4.cyan(item.name)}`);
    }
  }
  const payload = await fetchTree(library, Array.from(treeSet));
  if (!payload.length) {
    logger.warn("Selected items not found. Exiting.");
    process.exit(0);
  }
  await confirmOrQuit(
    `Ready to install ${payload.length} items from ${chalk4.cyan(
      library
    )}. Proceed?`
  );
  const libConfig = config?.libraries.find(({ name }) => name === library);
  if (!process.env.DIRECTORY && !libConfig) {
    logger.error(`Library ${library} not found in config`);
    process.exit(1);
  }
  const transformers = libConfig ? await resolveTransformers(libConfig.transformers) : [];
  for (const item of payload) {
    const targetDir = process.env.DIRECTORY || libConfig?.directory;
    if (!targetDir) {
      throw new Error("No target directory found. This shouldn't happen.");
    }
    if (!existsSync2(targetDir)) {
      await fs3.mkdir(targetDir, { recursive: true });
    }
    const existingComponent = item.files.filter(
      (file) => existsSync2(path3.resolve(targetDir, file.name))
    );
    if (existingComponent.length && !process.env.OVERWRITE) {
      if (selectedComponents.includes(item.name)) {
        logger.warn(
          `Component ${item.name} already exists. Use ${chalk4.green(
            "--overwrite"
          )} to overwrite.`
        );
        process.exit(1);
      }
      continue;
    }
    if (item.dependencies.length || item.devDependencies.length) {
      const shouldInstall = await confirm(
        [
          `${chalk4.cyan(item.name)} requires the following`,
          item.dependencies.length && "\nDependencies:",
          ...item.dependencies.map((dep) => `- ${chalk4.cyan(dep)}`),
          item.devDependencies.length && "\nDev Dependencies:",
          ...item.devDependencies.map((dep) => `
- ${chalk4.cyan(dep)}`),
          "\nProceed?"
        ].filter(Boolean).join("\n")
      );
      if (shouldInstall) {
        if (item.dependencies?.length) {
          await execa("npm", ["install", ...item.dependencies]);
        }
        if (item.devDependencies?.length) {
          await execa("npm", [
            "install",
            "--save-dev",
            ...item.devDependencies
          ]);
        }
      }
    }
    const itemSpinner = ora2(`  Installing ${item.name}...
`).start();
    for (const file of item.files) {
      const fileSpinner = ora2(`    Installing ${file.name}...
`).start();
      const output = await transformers.reduce(
        async (content, transformer) => transformer.default(await content, item.meta),
        Promise.resolve(file.content)
      );
      await fs3.writeFile(path3.resolve(targetDir, file.name), output);
      fileSpinner.succeed(`    Installed ${path3.join(targetDir, file.name)}`);
    }
    itemSpinner.succeed(`  Installed ${item.name}`);
  }
  if (libConfig?.postinstall && libConfig.postinstall.length > 0) {
    const cmd = typeof libConfig.postinstall === "string" ? libConfig.postinstall : libConfig.postinstall[0];
    const args = typeof libConfig.postinstall === "string" ? [] : libConfig.postinstall.slice(1);
    if (cmd) {
      await execa(cmd, args);
    }
  }
});

// src/commands/init.ts
import { Command as Command3 } from "commander";
import chalk5 from "chalk";
var init = new Command3().name("init").description("initialize your project and choose libraries").action(async () => {
  await configureLibraries();
  logger.info(`${chalk5.green("Success!")} Project initialization completed.`);
});

// src/index.ts
import { Command as Command5 } from "commander";

// src/commands/refresh.ts
import chalk6 from "chalk";
import { Command as Command4 } from "commander";
var refresh = new Command4().name("refresh").description("clear the cache and refresh the library index").action(() => {
  clearCache();
  logger.info(`${chalk6.green("Success!")} Cache cleared`);
  process.exit(1);
});

// src/check-version.ts
import { compareVersions } from "compare-versions";

// package.json
var package_default = {
  name: "@sly-cli/sly",
  version: "1.4.10",
  description: "Sly is a CLI tool to add components, icons, and utilities as code, not dependencies.",
  type: "module",
  exports: {
    ".": "./dist/index.js",
    "./ts-loader": "./ts-loader.js"
  },
  bin: {
    sly: "start.sh"
  },
  publishConfig: {
    access: "public"
  },
  license: "MIT",
  author: "Jacob Paris (https://twitter.com/jacobmparis)",
  repository: {
    type: "git",
    url: "git+https://github.com/jacobparis-insiders/sly.git",
    directory: "cli"
  },
  files: [
    "dist",
    "ts-loader.js"
  ],
  keywords: [
    "jacobparis"
  ],
  scripts: {
    dev: "tsup --watch",
    build: "tsup",
    typecheck: "tsc --noEmit",
    clean: "rimraf dist",
    "start:dev": "REGISTRY_URL=http://localhost:3000/registry node dist/index.js",
    start: "node dist/index.js",
    release: "changeset version",
    pub: "npm run build && npm publish --access public",
    test: "vitest run"
  },
  dependencies: {
    cachified: "^3.5.4",
    chalk: "^5.3.0",
    commander: "^11.0.0",
    "compare-versions": "^6.0.0",
    cosmiconfig: "^8.2.0",
    execa: "^7.1.1",
    "lru-cache": "^10.0.0",
    ora: "^6.3.1",
    prompts: "^2.4.2",
    zod: "^3.21.4"
  },
  devDependencies: {
    "@types/prompts": "^2.4.4",
    "@typescript-eslint/eslint-plugin": "^6.1.0",
    "@typescript-eslint/parser": "^6.1.0",
    esbuild: "^0.18.15",
    eslint: "^8.45.0",
    "eslint-plugin-no-template-curly-in-string-fix": "^1.0.4",
    prettier: "^3.0.0",
    rimraf: "^5.0.1",
    tsup: "^7.1.0",
    typescript: "^5.1.6"
  },
  types: "./dist/index.d.ts",
  bugs: {
    url: "https://github.com/jacobparis-insiders/sly/issues"
  },
  homepage: "https://github.com/jacobparis-insiders/sly#readme",
  main: "index.js"
};

// src/check-version.ts
import chalk7 from "chalk";
function checkVersion() {
  return getRegistryIndex().then(({ version }) => {
    const comparison = compareVersions(version, package_default.version);
    if (comparison === 1) {
      logger.warn(`Update available ${package_default.version} -> ${version}.`);
      logger.warn(
        `Run ${chalk7.bold("npm i --save-dev @sly-cli/sly")} to update.`
      );
    }
  });
}

// src/index.ts
process.on("SIGINT", () => process.exit(0));
process.on("SIGTERM", () => process.exit(0));
await checkVersion();
void restoreCache();
var program = new Command5().name("sly").description("add components, icons, and utilities as code, not dependencies").option("-y, --yes", "skip confirmation prompt.", false).option("--no-cache", "disable caching.", true).version("1.0.0", "-v, --version", "display the version number").hook("preAction", () => {
  const options = program.optsWithGlobals();
  process.env.YES = options.yes ? "true" : "";
  process.env.CACHE = options.cache ? "true" : "";
});
program.addCommand(init).addCommand(add).addCommand(refresh).addCommand(libraryCommand);
program.parse();
//# sourceMappingURL=index.js.map