{"version":3,"sources":["../src/index.ts","../src/lib.ts"],"sourcesContent":["export { createRoutesFromFolders } from \"./lib\";\nexport type { CreateRoutesFromFoldersOptions } from \"./lib\";\n","import fs from \"node:fs\";\nimport path from \"node:path\";\nimport minimatch from \"minimatch\";\nimport type {\n  RouteManifest,\n  DefineRouteFunction,\n  DefineRoutesFunction,\n} from \"@remix-run/dev/dist/config/routes\";\nimport { createRouteId } from \"@remix-run/dev/dist/config/routes\";\n\nlet paramPrefixChar = \"$\" as const;\nlet escapeStart = \"[\" as const;\nlet escapeEnd = \"]\" as const;\nlet optionalStart = \"(\" as const;\nlet optionalEnd = \")\" as const;\n\nlet routeModuleExts = [\".js\", \".jsx\", \".ts\", \".tsx\", \".md\", \".mdx\"];\n\nfunction isRouteModuleFile(filename: string): boolean {\n  return routeModuleExts.includes(path.extname(filename));\n}\n\nexport type CreateRoutesFromFoldersOptions = {\n  /**\n   * The directory where your app lives. Defaults to `app`.\n   * @default \"app\"\n   */\n  appDirectory?: string;\n  /**\n   * A list of glob patterns to ignore when looking for route modules.\n   * Defaults to `[]`.\n   */\n  ignoredFilePatterns?: string[];\n  /**\n   * The directory where your routes live. Defaults to `routes`.\n   * This is relative to `appDirectory`.\n   * @default \"routes\"\n   */\n  routesDirectory?: string;\n};\n\n/**\n * Defines routes using the filesystem convention in `app/routes`. The rules are:\n *\n * - Route paths are derived from the file path. A `.` in the filename indicates\n *   a `/` in the URL (a \"nested\" URL, but no route nesting). A `$` in the\n *   filename indicates a dynamic URL segment.\n * - Subdirectories are used for nested routes.\n *\n * For example, a file named `app/routes/gists/$username.tsx` creates a route\n * with a path of `gists/:username`.\n */\nexport function createRoutesFromFolders(\n  defineRoutes: DefineRoutesFunction,\n  options: CreateRoutesFromFoldersOptions = {}\n): RouteManifest {\n  let {\n    appDirectory = \"app\",\n    ignoredFilePatterns = [],\n    routesDirectory = \"routes\",\n  } = options;\n\n  let appRoutesDirectory = path.join(appDirectory, routesDirectory);\n  let files: { [routeId: string]: string } = {};\n\n  // First, find all route modules in app/routes\n  visitFiles(appRoutesDirectory, (file) => {\n    if (\n      ignoredFilePatterns.length > 0 &&\n      ignoredFilePatterns.some((pattern) => minimatch(file, pattern))\n    ) {\n      return;\n    }\n\n    if (isRouteModuleFile(file)) {\n      let relativePath = path.join(routesDirectory, file);\n      let routeId = createRouteId(relativePath);\n      files[routeId] = relativePath;\n      return;\n    }\n\n    throw new Error(\n      `Invalid route module file: ${path.join(appRoutesDirectory, file)}`\n    );\n  });\n\n  let routeIds = Object.keys(files).sort(byLongestFirst);\n  let parentRouteIds = getParentRouteIds(routeIds);\n  let uniqueRoutes = new Map<string, string>();\n\n  // Then, recurse through all routes using the public defineRoutes() API\n  function defineNestedRoutes(\n    defineRoute: DefineRouteFunction,\n    parentId?: string\n  ): void {\n    let childRouteIds = routeIds.filter((id) => {\n      return parentRouteIds[id] === parentId;\n    });\n\n    for (let routeId of childRouteIds) {\n      let routePath: string | undefined = createRoutePath(\n        routeId.slice((parentId || routesDirectory).length + 1)\n      );\n\n      let isIndexRoute = routeId.endsWith(\"/index\");\n      let fullPath = createRoutePath(routeId.slice(routesDirectory.length + 1));\n      let uniqueRouteId = (fullPath || \"\") + (isIndexRoute ? \"?index\" : \"\");\n      let isPathlessLayoutRoute =\n        routeId.split(\"/\").pop()?.startsWith(\"__\") === true;\n\n      /**\n       * We do not try to detect path collisions for pathless layout route\n       * files because, by definition, they create the potential for route\n       * collisions _at that level in the tree_.\n       *\n       * Consider example where a user may want multiple pathless layout routes\n       * for different subfolders\n       *\n       *   routes/\n       *     account.tsx\n       *     account/\n       *       __public/\n       *         login.tsx\n       *         perks.tsx\n       *       __private/\n       *         orders.tsx\n       *         profile.tsx\n       *       __public.tsx\n       *       __private.tsx\n       *\n       * In order to support both a public and private layout for `/account/*`\n       * URLs, we are creating a mutually exclusive set of URLs beneath 2\n       * separate pathless layout routes.  In this case, the route paths for\n       * both account/__public.tsx and account/__private.tsx is the same\n       * (/account), but we're again not expecting to match at that level.\n       *\n       * By only ignoring this check when the final portion of the filename is\n       * pathless, we will still detect path collisions such as:\n       *\n       *   routes/parent/__pathless/foo.tsx\n       *   routes/parent/__pathless2/foo.tsx\n       *\n       * and\n       *\n       *   routes/parent/__pathless/index.tsx\n       *   routes/parent/__pathless2/index.tsx\n       */\n      if (uniqueRouteId && !isPathlessLayoutRoute) {\n        if (uniqueRoutes.has(uniqueRouteId)) {\n          throw new Error(\n            `Path ${JSON.stringify(fullPath || \"/\")} defined by route ` +\n              `${JSON.stringify(routeId)} conflicts with route ` +\n              `${JSON.stringify(uniqueRoutes.get(uniqueRouteId))}`\n          );\n        } else {\n          uniqueRoutes.set(uniqueRouteId, routeId);\n        }\n      }\n\n      if (isIndexRoute) {\n        let invalidChildRoutes = routeIds.filter(\n          (id) => parentRouteIds[id] === routeId\n        );\n\n        if (invalidChildRoutes.length > 0) {\n          throw new Error(\n            `Child routes are not allowed in index routes. Please remove child routes of ${routeId}`\n          );\n        }\n\n        defineRoute(routePath, files[routeId], { index: true, id: routeId });\n      } else {\n        defineRoute(routePath, files[routeId], { id: routeId }, () => {\n          defineNestedRoutes(defineRoute, routeId);\n        });\n      }\n    }\n  }\n\n  return defineRoutes(defineNestedRoutes);\n}\n\n// TODO: Cleanup and write some tests for this function\nexport function createRoutePath(partialRouteId: string): string | undefined {\n  let result = \"\";\n  let rawSegmentBuffer = \"\";\n\n  let inEscapeSequence = 0;\n  let inOptionalSegment = 0;\n  let optionalSegmentIndex = null;\n  let skipSegment = false;\n  for (let i = 0; i < partialRouteId.length; i++) {\n    let char = partialRouteId.charAt(i);\n    let prevChar = i > 0 ? partialRouteId.charAt(i - 1) : undefined;\n    let nextChar =\n      i < partialRouteId.length - 1 ? partialRouteId.charAt(i + 1) : undefined;\n\n    function isNewEscapeSequence() {\n      return (\n        !inEscapeSequence && char === escapeStart && prevChar !== escapeStart\n      );\n    }\n\n    function isCloseEscapeSequence() {\n      return inEscapeSequence && char === escapeEnd && nextChar !== escapeEnd;\n    }\n\n    function isStartOfLayoutSegment() {\n      return char === \"_\" && nextChar === \"_\" && !rawSegmentBuffer;\n    }\n\n    function isNewOptionalSegment() {\n      return (\n        char === optionalStart &&\n        prevChar !== optionalStart &&\n        (isSegmentSeparator(prevChar) || prevChar === undefined) &&\n        !inOptionalSegment &&\n        !inEscapeSequence\n      );\n    }\n\n    function isCloseOptionalSegment() {\n      return (\n        char === optionalEnd &&\n        nextChar !== optionalEnd &&\n        (isSegmentSeparator(nextChar) || nextChar === undefined) &&\n        inOptionalSegment &&\n        !inEscapeSequence\n      );\n    }\n\n    if (skipSegment) {\n      if (isSegmentSeparator(char)) {\n        skipSegment = false;\n      }\n      continue;\n    }\n\n    if (isNewEscapeSequence()) {\n      inEscapeSequence++;\n      continue;\n    }\n\n    if (isCloseEscapeSequence()) {\n      inEscapeSequence--;\n      continue;\n    }\n\n    if (isNewOptionalSegment()) {\n      inOptionalSegment++;\n      optionalSegmentIndex = result.length;\n      result += optionalStart;\n      continue;\n    }\n\n    if (isCloseOptionalSegment()) {\n      if (optionalSegmentIndex !== null) {\n        result =\n          result.slice(0, optionalSegmentIndex) +\n          result.slice(optionalSegmentIndex + 1);\n      }\n      optionalSegmentIndex = null;\n      inOptionalSegment--;\n      result += \"?\";\n      continue;\n    }\n\n    if (inEscapeSequence) {\n      result += char;\n      continue;\n    }\n\n    if (isSegmentSeparator(char)) {\n      if (rawSegmentBuffer === \"index\" && result.endsWith(\"index\")) {\n        result = result.replace(/\\/?index$/, \"\");\n      } else {\n        result += \"/\";\n      }\n\n      rawSegmentBuffer = \"\";\n      inOptionalSegment = 0;\n      optionalSegmentIndex = null;\n      continue;\n    }\n\n    if (isStartOfLayoutSegment()) {\n      skipSegment = true;\n      continue;\n    }\n\n    rawSegmentBuffer += char;\n\n    if (char === paramPrefixChar) {\n      if (nextChar === optionalEnd) {\n        throw new Error(\n          `Invalid route path: ${partialRouteId}. Splat route $ is already optional`\n        );\n      }\n      result += typeof nextChar === \"undefined\" ? \"*\" : \":\";\n      continue;\n    }\n\n    result += char;\n  }\n\n  if (rawSegmentBuffer === \"index\" && result.endsWith(\"index\")) {\n    result = result.replace(/\\/?index$/, \"\");\n  } else {\n    result = result.replace(/\\/$/, \"\");\n  }\n\n  if (rawSegmentBuffer === \"index\" && result.endsWith(\"index?\")) {\n    throw new Error(\n      `Invalid route path: ${partialRouteId}. Make index route optional by using (index)`\n    );\n  }\n\n  return result || undefined;\n}\n\nfunction isSegmentSeparator(checkChar: string | undefined) {\n  if (!checkChar) return false;\n  return [\"/\", \".\", path.win32.sep].includes(checkChar);\n}\n\nfunction getParentRouteIds(\n  routeIds: string[]\n): Record<string, string | undefined> {\n  return routeIds.reduce<Record<string, string | undefined>>(\n    (parentRouteIds, childRouteId) => ({\n      ...parentRouteIds,\n      [childRouteId]: routeIds.find((id) => childRouteId.startsWith(`${id}/`)),\n    }),\n    {}\n  );\n}\n\nfunction byLongestFirst(a: string, b: string): number {\n  return b.length - a.length;\n}\n\nfunction visitFiles(\n  dir: string,\n  visitor: (file: string) => void,\n  baseDir = dir\n): void {\n  for (let filename of fs.readdirSync(dir)) {\n    let file = path.resolve(dir, filename);\n    let stat = fs.lstatSync(file);\n\n    if (stat.isDirectory()) {\n      visitFiles(file, visitor, baseDir);\n    } else if (stat.isFile()) {\n      visitor(path.relative(baseDir, file));\n    }\n  }\n}\n\n/*\neslint\n  no-loop-func: \"off\",\n*/\n"],"mappings":"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","names":["path","minimatch","isNewEscapeSequence","isCloseEscapeSequence","isStartOfLayoutSegment","isNewOptionalSegment","isCloseOptionalSegment","fs"]}