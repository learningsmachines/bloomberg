"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  createRoutesFromFolders: () => createRoutesFromFolders
});
module.exports = __toCommonJS(src_exports);

// src/lib.ts
var import_node_fs = __toESM(require("fs"));
var import_node_path = __toESM(require("path"));
var import_minimatch = __toESM(require("minimatch"));
var import_routes = require("@remix-run/dev/dist/config/routes");
var paramPrefixChar = "$";
var escapeStart = "[";
var escapeEnd = "]";
var optionalStart = "(";
var optionalEnd = ")";
var routeModuleExts = [".js", ".jsx", ".ts", ".tsx", ".md", ".mdx"];
function isRouteModuleFile(filename) {
  return routeModuleExts.includes(import_node_path.default.extname(filename));
}
function createRoutesFromFolders(defineRoutes, options = {}) {
  let {
    appDirectory = "app",
    ignoredFilePatterns = [],
    routesDirectory = "routes"
  } = options;
  let appRoutesDirectory = import_node_path.default.join(appDirectory, routesDirectory);
  let files = {};
  visitFiles(appRoutesDirectory, (file) => {
    if (ignoredFilePatterns.length > 0 && ignoredFilePatterns.some((pattern) => (0, import_minimatch.default)(file, pattern))) {
      return;
    }
    if (isRouteModuleFile(file)) {
      let relativePath = import_node_path.default.join(routesDirectory, file);
      let routeId = (0, import_routes.createRouteId)(relativePath);
      files[routeId] = relativePath;
      return;
    }
    throw new Error(
      `Invalid route module file: ${import_node_path.default.join(appRoutesDirectory, file)}`
    );
  });
  let routeIds = Object.keys(files).sort(byLongestFirst);
  let parentRouteIds = getParentRouteIds(routeIds);
  let uniqueRoutes = /* @__PURE__ */ new Map();
  function defineNestedRoutes(defineRoute, parentId) {
    let childRouteIds = routeIds.filter((id) => {
      return parentRouteIds[id] === parentId;
    });
    for (let routeId of childRouteIds) {
      let routePath = createRoutePath(
        routeId.slice((parentId || routesDirectory).length + 1)
      );
      let isIndexRoute = routeId.endsWith("/index");
      let fullPath = createRoutePath(routeId.slice(routesDirectory.length + 1));
      let uniqueRouteId = (fullPath || "") + (isIndexRoute ? "?index" : "");
      let isPathlessLayoutRoute = routeId.split("/").pop()?.startsWith("__") === true;
      if (uniqueRouteId && !isPathlessLayoutRoute) {
        if (uniqueRoutes.has(uniqueRouteId)) {
          throw new Error(
            `Path ${JSON.stringify(fullPath || "/")} defined by route ${JSON.stringify(routeId)} conflicts with route ${JSON.stringify(uniqueRoutes.get(uniqueRouteId))}`
          );
        } else {
          uniqueRoutes.set(uniqueRouteId, routeId);
        }
      }
      if (isIndexRoute) {
        let invalidChildRoutes = routeIds.filter(
          (id) => parentRouteIds[id] === routeId
        );
        if (invalidChildRoutes.length > 0) {
          throw new Error(
            `Child routes are not allowed in index routes. Please remove child routes of ${routeId}`
          );
        }
        defineRoute(routePath, files[routeId], { index: true, id: routeId });
      } else {
        defineRoute(routePath, files[routeId], { id: routeId }, () => {
          defineNestedRoutes(defineRoute, routeId);
        });
      }
    }
  }
  return defineRoutes(defineNestedRoutes);
}
function createRoutePath(partialRouteId) {
  let result = "";
  let rawSegmentBuffer = "";
  let inEscapeSequence = 0;
  let inOptionalSegment = 0;
  let optionalSegmentIndex = null;
  let skipSegment = false;
  for (let i = 0; i < partialRouteId.length; i++) {
    let isNewEscapeSequence2 = function() {
      return !inEscapeSequence && char === escapeStart && prevChar !== escapeStart;
    }, isCloseEscapeSequence2 = function() {
      return inEscapeSequence && char === escapeEnd && nextChar !== escapeEnd;
    }, isStartOfLayoutSegment2 = function() {
      return char === "_" && nextChar === "_" && !rawSegmentBuffer;
    }, isNewOptionalSegment2 = function() {
      return char === optionalStart && prevChar !== optionalStart && (isSegmentSeparator(prevChar) || prevChar === void 0) && !inOptionalSegment && !inEscapeSequence;
    }, isCloseOptionalSegment2 = function() {
      return char === optionalEnd && nextChar !== optionalEnd && (isSegmentSeparator(nextChar) || nextChar === void 0) && inOptionalSegment && !inEscapeSequence;
    };
    var isNewEscapeSequence = isNewEscapeSequence2, isCloseEscapeSequence = isCloseEscapeSequence2, isStartOfLayoutSegment = isStartOfLayoutSegment2, isNewOptionalSegment = isNewOptionalSegment2, isCloseOptionalSegment = isCloseOptionalSegment2;
    let char = partialRouteId.charAt(i);
    let prevChar = i > 0 ? partialRouteId.charAt(i - 1) : void 0;
    let nextChar = i < partialRouteId.length - 1 ? partialRouteId.charAt(i + 1) : void 0;
    if (skipSegment) {
      if (isSegmentSeparator(char)) {
        skipSegment = false;
      }
      continue;
    }
    if (isNewEscapeSequence2()) {
      inEscapeSequence++;
      continue;
    }
    if (isCloseEscapeSequence2()) {
      inEscapeSequence--;
      continue;
    }
    if (isNewOptionalSegment2()) {
      inOptionalSegment++;
      optionalSegmentIndex = result.length;
      result += optionalStart;
      continue;
    }
    if (isCloseOptionalSegment2()) {
      if (optionalSegmentIndex !== null) {
        result = result.slice(0, optionalSegmentIndex) + result.slice(optionalSegmentIndex + 1);
      }
      optionalSegmentIndex = null;
      inOptionalSegment--;
      result += "?";
      continue;
    }
    if (inEscapeSequence) {
      result += char;
      continue;
    }
    if (isSegmentSeparator(char)) {
      if (rawSegmentBuffer === "index" && result.endsWith("index")) {
        result = result.replace(/\/?index$/, "");
      } else {
        result += "/";
      }
      rawSegmentBuffer = "";
      inOptionalSegment = 0;
      optionalSegmentIndex = null;
      continue;
    }
    if (isStartOfLayoutSegment2()) {
      skipSegment = true;
      continue;
    }
    rawSegmentBuffer += char;
    if (char === paramPrefixChar) {
      if (nextChar === optionalEnd) {
        throw new Error(
          `Invalid route path: ${partialRouteId}. Splat route $ is already optional`
        );
      }
      result += typeof nextChar === "undefined" ? "*" : ":";
      continue;
    }
    result += char;
  }
  if (rawSegmentBuffer === "index" && result.endsWith("index")) {
    result = result.replace(/\/?index$/, "");
  } else {
    result = result.replace(/\/$/, "");
  }
  if (rawSegmentBuffer === "index" && result.endsWith("index?")) {
    throw new Error(
      `Invalid route path: ${partialRouteId}. Make index route optional by using (index)`
    );
  }
  return result || void 0;
}
function isSegmentSeparator(checkChar) {
  if (!checkChar)
    return false;
  return ["/", ".", import_node_path.default.win32.sep].includes(checkChar);
}
function getParentRouteIds(routeIds) {
  return routeIds.reduce(
    (parentRouteIds, childRouteId) => ({
      ...parentRouteIds,
      [childRouteId]: routeIds.find((id) => childRouteId.startsWith(`${id}/`))
    }),
    {}
  );
}
function byLongestFirst(a, b) {
  return b.length - a.length;
}
function visitFiles(dir, visitor, baseDir = dir) {
  for (let filename of import_node_fs.default.readdirSync(dir)) {
    let file = import_node_path.default.resolve(dir, filename);
    let stat = import_node_fs.default.lstatSync(file);
    if (stat.isDirectory()) {
      visitFiles(file, visitor, baseDir);
    } else if (stat.isFile()) {
      visitor(import_node_path.default.relative(baseDir, file));
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createRoutesFromFolders
});
//# sourceMappingURL=index.js.map