/**
 * @remix-run/testing v2.3.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var router = require('@remix-run/router');
var react = require('@remix-run/react');
var reactRouterDom = require('react-router-dom');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

function createRemixStub(routes, context = {}) {
  return function RemixStub({
    initialEntries,
    initialIndex,
    hydrationData,
    future
  }) {
    let routerRef = React__namespace.useRef();
    let remixContextRef = React__namespace.useRef();
    if (routerRef.current == null) {
      remixContextRef.current = {
        future: {
          v3_fetcherPersist: (future === null || future === void 0 ? void 0 : future.v3_fetcherPersist) === true
        },
        manifest: {
          routes: {},
          entry: {
            imports: [],
            module: ""
          },
          url: "",
          version: ""
        },
        routeModules: {}
      };

      // Update the routes to include context in the loader/action and populate
      // the manifest and routeModules during the walk
      let patched = processRoutes(
      // @ts-expect-error loader/action context types don't match :/
      router.UNSAFE_convertRoutesToDataRoutes(routes, r => r), context, remixContextRef.current.manifest, remixContextRef.current.routeModules);
      routerRef.current = reactRouterDom.createMemoryRouter(patched, {
        initialEntries,
        initialIndex,
        hydrationData
      });
    }
    return /*#__PURE__*/React__namespace.createElement(react.UNSAFE_RemixContext.Provider, {
      value: remixContextRef.current
    }, /*#__PURE__*/React__namespace.createElement(reactRouterDom.RouterProvider, {
      router: routerRef.current
    }));
  };
}
function processRoutes(routes, context, manifest, routeModules, parentId) {
  return routes.map(route => {
    if (!route.id) {
      throw new Error("Expected a route.id in @remix-run/testing processRoutes() function");
    }

    // Patch in the Remix context to loaders/actions
    let {
      loader,
      action
    } = route;
    let newRoute = {
      id: route.id,
      path: route.path,
      index: route.index,
      Component: route.Component,
      ErrorBoundary: route.ErrorBoundary,
      action: action ? args => action({
        ...args,
        context
      }) : undefined,
      loader: loader ? args => loader({
        ...args,
        context
      }) : undefined,
      handle: route.handle,
      shouldRevalidate: route.shouldRevalidate
    };

    // Add the EntryRoute to the manifest
    let entryRoute = {
      id: route.id,
      path: route.path,
      index: route.index,
      parentId,
      hasAction: route.action != null,
      hasLoader: route.loader != null,
      hasErrorBoundary: route.ErrorBoundary != null,
      module: "build/stub-path-to-module.js" // any need for this?
    };

    manifest.routes[newRoute.id] = entryRoute;

    // Add the route to routeModules
    routeModules[route.id] = {
      default: route.Component || reactRouterDom.Outlet,
      ErrorBoundary: route.ErrorBoundary || undefined,
      handle: route.handle,
      links: route.links,
      meta: route.meta,
      shouldRevalidate: route.shouldRevalidate
    };
    if (route.children) {
      newRoute.children = processRoutes(route.children, context, manifest, routeModules, newRoute.id);
    }
    return newRoute;
  });
}

exports.createRemixStub = createRemixStub;
