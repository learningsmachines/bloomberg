Object.defineProperty(exports, '__esModule', { value: true });

const core = require('@sentry/core');
const utils = require('@sentry/utils');
const response = require('../utils/vendor/response.js');

/**
 * Captures an error that is thrown inside a Remix ErrorBoundary.
 *
 * @param error The error to capture.
 * @returns void
 */
function captureRemixErrorBoundaryError(error) {
  let eventId;
  const isClientSideRuntimeError = !utils.isNodeEnv() && error instanceof Error;
  const isRemixErrorResponse = response.isRouteErrorResponse(error);
  // Server-side errors apart from `ErrorResponse`s also appear here without their stacktraces.
  // So, we only capture:
  //    1. `ErrorResponse`s
  //    2. Client-side runtime errors here,
  //    And other server-side errors captured in `handleError` function where stacktraces are available.
  if (isRemixErrorResponse || isClientSideRuntimeError) {
    const eventData = isRemixErrorResponse
      ? {
          function: 'ErrorResponse',
          ...error.data,
        }
      : {
          function: 'ReactError',
        };

    core.withScope(scope => {
      scope.addEventProcessor(event => {
        utils.addExceptionMechanism(event, {
          type: 'instrument',
          handled: false,
          data: eventData,
        });
        return event;
      });

      if (isRemixErrorResponse) {
        if (utils.isString(error.data)) {
          eventId = core.captureException(error.data);
        } else if (error.statusText) {
          eventId = core.captureException(error.statusText);
        } else {
          eventId = core.captureException(error);
        }
      } else {
        eventId = core.captureException(error);
      }
    });
  }

  return eventId;
}

exports.captureRemixErrorBoundaryError = captureRemixErrorBoundaryError;
//# sourceMappingURL=errors.js.map
